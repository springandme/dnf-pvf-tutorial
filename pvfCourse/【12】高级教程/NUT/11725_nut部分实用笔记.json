{
    "content": "<pre>\n<code class=\"language-javascript\">//挂载外部文件 #本地测试 #不用退游戏就更改源码\ndofile(\"以客户端为根目录的路径\");\n//函数名事件 #人物状态 #特效 #ap #事件函数 #某一个事件达成时会运行的函数\n//角色事件函数名 #角色的事件不是状态的\n//被动技能 使用被动技能 #被动技能的设置\nfunction ProcPassiveSkill_ATMage(obj, skill_index, skill_level)\n{\n        if (skill_index == SKILL_EXPRESSION)\n        {\n                if(skill_level &gt; 0)\n                {\n                        local appendage = CNSquirrelAppendage.sq_AppendAppendage(obj, obj, skill_index, false, \"Character/ATMage/Expressions/ap_atmage_expression.nut\", true);\n                                print(\" expression appendage:\" + appendage);\n                        if(appendage)\n                        {\n\n\n\n\n                                                                local magicalAtkChangeRate = sq_GetLevelData(obj, skill_index, SKL_LVL_COLUMN_IDX_1, skill_level);                \n                                local change_appendage = appendage.sq_getChangeStatus(\"expression\");\n                                if(!change_appendage) {\n                                        change_appendage = appendage.sq_AddChangeStatus(\"expression\",obj, obj, 0, CHANGE_STATUS_TYPE_MAGICAL_ATTACK, false, magicalAtkChangeRate );\n                                }\n                                if(change_appendage)\n                                {\n                                        change_appendage.clearParameter();\n                                        print(\" expression attack rate:\" + magicalAtkChangeRate.tofloat());\n                                        change_appendage.addParameter(CHANGE_STATUS_TYPE_MAGICAL_ATTACK, false, magicalAtkChangeRate.tofloat());\n                                }\n                        }\n                }\n        }\n        else if(skill_index == SKILL_DIEHARD)\n        { // 碳餌\n                if(skill_level &gt; 0)\n                {\n                        local appendage = CNSquirrelAppendage.sq_AppendAppendage(obj, obj, skill_index, false, \n                        \"Character/ATMage/DieHard/ap_ATMage_DieHard.nut\", true);\n                        if(appendage)\n                        {\n                        }\n                }\n        }\n        else if(skill_index == SKILL_TUNDRASOUL)\n        { // 矗萄塭曖 陛\n                if(skill_level &gt; 0)\n                {\n                        local skill = sq_GetSkill(obj, SKILL_TUNDRASOUL);\n                        if(!skill)\n                                return true;\n                        print( \" passive_skill_tundrasoul\");\n                        //if(!skill.isSealFunction())\n                        {\n                                local appendage = CNSquirrelAppendage.sq_AppendAppendage(obj, obj, skill_index, false, \n                                \"Character/ATMage/TundraSoul/ap_ATMage_TundraSoul.nut\", true);\n                                if(appendage)\n                                {\n                                        print(\" passive object isinBattle:\" + obj.isInBattle());\n                                        //if(!skill.isSealFunction())\n                                        //{\n                                                //if(sq_IsInBattle())\n                                                //{\n                                                        //local range = obj.sq_GetIntData(SKILL_TUNDRASOUL , 0);// 0. 綵唸 鼻鷓檜鼻縑 勘葬朝 婁彰嬪\n                                                        //local AuraTundraSoulAppendage = appendage.sq_AddSquirrelAuraMaster(\"AuraTundraSoul\",obj, obj, range, 18, 5, 0);\n                                                //}\n                                                //else\n                                                //{\n                                                        //appendage.sq_DeleteAppendages();\n                                                //}\n                                        //}\n                                        //else\n                                        //{\n                                                //appendage.sq_DeleteAppendages();\n                                        //}\n                                }\n                        }\n                }\n        }\n        return true;\n}\nfunction onUseSkillPassiveSkill_ATMage(obj,skillIndex, skillLevel)\n{\n        if(!obj)\n\n\n                                return;        \n        print( \" onuseskill\");\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//刷新技能按键状态时 #这里可以设置技能亮不亮\nfunction flushCommandEnable_Avenger(obj)\n{\n        if (!obj) return S_FLOW_NORMAL;\n        if (!obj.isInBattle())\n        {\n                sq_SetAllCommandEnable(obj, false); // 瞪癱醞橾隆 賅萇 蝶鑒擊 餌辨 熱 橈蝗棲棻.\n                return S_FLOW_RETURN;\n        }\n        if (isAvengerAwakenning(obj) == true)\n        {\n                if (obj.isMyControlObject())\n                        sq_SetAllCommandEnable(obj, false); // 賅萇 state蒂 殘嬴場朝棻..\n\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//增加设置状态包时 #可以驳回状态 #且可以再次设置别的状态\nfunction addSetStatePacket_Avenger(obj, state, datas)\n{\n        if (!obj)\n                return -1;\n        if (isAvengerAwakenning(obj) == true)\n        {\n                switch (state)\n                {\n                case 7://發送過來的狀態是跳躍攻擊 源狀態是跳躍 則 發給覺醒狀態 來跳躍攻擊\n            if(obj.getState()==6)\n            {\n                obj.sq_IntVectClear();\n                obj.sq_IntVectPush(4); // substate撮\n                obj.sq_addSetStatePacket(STATE_AVENGER_AWAKENING, STATE_PRIORITY_USER, true);\n                return -1;\n            }\n            break;\n        }\n    }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//进入副本时\nfunction onStartDungeon_CreatorMage(obj)\n{\n        if (!obj)\n                return;\n        if (sq_IsMyCharacter(obj))\n        {\n                lockMouse(obj);\n                //////////////////////////////////////////////////////\n                obj.getVar(\"lbdown\").clear_timer_vector();\n                obj.getVar(\"lbdown\").push_timer_vector();\n                obj.getVar(\"lbdown\").push_timer_vector();\n\n                local t = obj.getVar(\"lbdown\").get_timer_vector(0);\n                t.setParameter(20, -1);\n                t.resetInstant(0);\n                obj.getVar(\"lbdown\").clear_ct_vector();\n                obj.getVar(\"lbdown\").push_ct_vector();\n                local timer = obj.getVar(\"lbdown\").get_ct_vector(0);\n                timer.Reset();\n                timer.Start(10000,0);\n                //////////////////////////////////////////////////////\n                // 觼溯檜攪曖 賅萇 樓撩 啪檜雖 醱瞪擊 衛濛棲棻.\n                onAllChargeCreatorMageGauge(obj);\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//进入map房间时\nfunction onStartMap_CreatorMage(obj)\n{\n        if(!obj)\n                return;\n        lockMouse(obj);\n        obj.getVar(\"dstpos\").clear_vector();\n        // 寞檜 剩橫鬲朝等 熱 橫蛤雖陛 氈棻賊..\n        // 餉薯鄹棲棻.\n        // 棻擠寞縑憮紫 婁陛 雖樓腎晦 陽僥殮棲棻.\n        local appendage = CNSquirrelAppendage.sq_GetAppendage(obj, \"Appendage/Character/ap_common_suck.nut\");\n        if (appendage)\n        {\n                appendage.sq_DeleteAppendages();\n                CNSquirrelAppendage.sq_RemoveAppendage(obj, \"Appendage/Character/ap_common_suck.nut\");\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//设置状态时\nfunction setState_ATMage(obj, state, datas, isResetTimer)\n{\n        if(state == STATE_DIE)               \n        obj.sq_RemoveSkillLoad(SKILL_HOLONG_LIGHT);    // 避戲賊 煬碳 UI 薯剪\n        return 0;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//被动\nfunction procAppend_CreatorMage(obj)\n{\n        if (!obj)\n                return 0;\n        local type = getCreatorSkillStateSkillIndex(obj);\n        if (type == CREATOR_TYPE_DISTURB)\n        {\n                onProc_Mgrab(obj);\n        }\n        if (!obj.isMyControlObject())\n                return 0;\n        local STATE_ACTIVE = 1;        \n        local cashState = sq_GetStateCashShop();\n        local isClipCursor = sq_IsClipCursor(); // 醴憮陛 陘氈朝雖 羹觼棲棻.\n        if (cashState == STATE_ACTIVE)\n        {\n                // 撮塭憧檜 翮溜朝等 醴憮陛 off賅萄陛 腎橫憮朝 寰腌棲棻.\n                if (isClipCursor)\n                 unLockMouse(obj);\n        }\n        else\n        {\n                // 葆辦蝶塊檜 葬雖 彊擎 唳辦 葆雖虞 湍瞪 贗葬橫鼻鷓檣雖 羹觼瑣棲棻.\n                if (sq_GetResultState() || sq_GetRewardState())\n                {\n                        // 唸婁璽檜 釭螃朝 翕寰縑紫 鼻濠蛔擊 睡敷幗葬晦 嬪\n                        // 檜廓縛 羲戲煎 ui撩酈蒂 援腦賊 葆辦蝶蒂 濡掬幗董棲棻.\n                        local hotKey = sq_IsDownHotKeyCreatorCursor();\n                        if (hotKey)\n                        {\n                                // ui撩酈陛 揚萼鼻鷓縑憮朝 贗董檜 溥氈棻賊..\n                                // 棻衛 濡掬幗董棲棻.\n                                if (!isClipCursor)\n                                        lockMouse(obj);\n                        }\n                        else\n                        {\n                                if (isClipCursor)\n                                {\n                                   unLockMouse(obj);\n                                }\n                        }\n                        return 0;\n                }\n                if (IsInBattleCreator(obj))\n                { // 瞪濰醞檜塭賊..\n                        local hotKey = sq_IsDownHotKeyCreatorCursor();\n                        if (hotKey)\n                        {\n                                // ui撩 酈蒂 援艇 鼻鷓縑歙 葆辦蝶陛 濡啣朝雖 羹觼瑣棲棻.\n                                if (isClipCursor)\n                                {\n                                        // 葆辦蝶陛 濡啣棻賊\n                                        unLockMouse(obj);\n                                }\n                        }\n                        else\n                        {\n                                // 營 葆辦蝶 謝陛 孺紫辦 賊寰薹縑 氈朝 羹觼棲棻.\n                                //print(\" isClipCursor:\" + isClipCursor);\n                                if (!isClipCursor)\n\n\n\n\n                                                                        { // 葆辦蝶塊檜 萼 鼻鷓塭賊                    \n                                        //print(\" isopencreator:\" + sq_IsOpenCreatorControlPopupWindows());\n                                        if (!sq_IsOpenCreatorControlPopupWindows())\n                                        {\n                                                if (sq_IsMousePtInWindowRect())\n                                                { // 葆辦蝶陛 頂睡縑 謝蒂 氈棻賊..\n                                                        // ui撩 酈蒂 援艇 鼻鷓縑憮 諼睡瓣璽擊 援腦賊 橾衛瞳戲煎 \n                                                        // ui撩 酈陛 false煎 腎朝等 檜陽 葆辦蝶塊擊 勘橫輿賊 寰腌棲棻.\n                                                        lockMouse(obj);\n                                                }\n                                        }\n                                }\n                        }\n                }\n                else\n                {\n                        if (isClipCursor == true)\n                        {\n                                unLockMouse(obj);\n                        }\n                }\n        }\n        return 1;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//前冲被动\nfunction procDash_ATMage(obj)\n{\n        if(!obj)\n           return;\n        local ani = sq_GetCurrentAnimation(obj);\n        if(!ani)\n           return;\n        local isFlag = obj.sq_IsKeyFrameFlag(ani, 1);\n        local result = CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"Character/ATMage/IceRoad/ap_ATMage_IceRoad.nut\");\n        if (result == true) // 嬴檜蝶煎萄蒂 麵堡擊 隆 嫦濠措模葬陛 夥荸棲棻.\n        {\n                if(isFlag)\n                {\n                     obj.sq_PlaySound(\"R_ICE_WALK\");\n                }\n                obj.sq_ClearKeyFrameFlag(ani);\n        }\n        else\n        {\n                //print(\" procDash\");\n                if (isFlag)\n                {\n                        local stage = sq_GetGlobaludpModuleStage();\n                        if(!stage)\n                                return;\n                        local dungeon = sq_GetDungeonByStage(stage);\n                        if(!dungeon)\n                                return;\n\n                        local dungeonIndex = sq_GetDuegonIndex(dungeon);            \n                        local mapIndex = sq_GetMapIndex(stage);\n                        //撲骯薹 湍瞪曖 唳辦 40廓, 撲骯曖 蹺瞳 PVP裘曖 唳辦 50019廓.\n                        if (dungeonIndex == 40 || mapIndex == 50019)\n                        {\n                                obj.sq_PlaySound(\"R_RUN_SNOW\");\n                        }\n                        else\n                        {\n                                local weight = sq_GetObjectWeight(obj);\n                                if (sq_GetShadowTypeByAnimation() != 0)\n                                        obj.sq_PlaySound(\"R_RUN_FLOOR\");\n                                else if (weight &lt; LIGHT_OBJECT_MAX_WEIGHT)\n                                        obj.sq_PlaySound(\"RUN_STONE\");\n                                else if (weight &lt; MIDDLE_OBJECT_MAX_WEIGHT)\n                                        obj.sq_PlaySound(\"RUN_SOIL\");\n                                else\n                                        obj.sq_PlaySound(\"RUN_GRASS\");\n                        }\n                }\n                obj.sq_ClearKeyFrameFlag(ani);\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//被动技能\nfunction procSkill_ATMage(obj)\n{\n        procSkill_IceRoad(obj);\n        procSkill_MagicShield(obj);\n}\nfunction procSkill_IceRoad(obj)\n{\n        local appendage = obj.GetSquirrelAppendage(\"Character/ATMage/IceRoad/ap_ATMage_IceRoad.nut\");\n        if(appendage) {\n                local isvalid = appendage.isValid();\n                if(isvalid) {\n                        local currentT = appendage.getTimer().Get();\n                        local t = appendage.sq_var.get_timer_vector(0);\n                        local t2 = appendage.sq_var.get_timer_vector(1); // 橡擠褻陝擊 虜萄朝匙婁 滌紫煎 縞模賅朝 棻艇顫檜該煎 給嬴陛憮 mp模賅蒂 衛霾棲棻.\n                        if (t2.isOnEvent(currentT) == true)\n                        {\n                                local skill = sq_GetSkill(obj, SKILL_ICEROAD);\n                                if(skill)\n                                {\n                                        local skill_level = obj.sq_GetSkillLevel(SKILL_ICEROAD);\n                                        local spendMp = obj.sq_GetLevelData(SKILL_ICEROAD, SKL_LV_0, skill_level); // 0.衛除渡MP 模賅榆\n                                        if (spendMp &gt; obj.getMp())\n                                        {\n                                                appendage.setValid(false);\n                                                skill.setSealActiveFunction(true);\n                                                return;\n                                        }\n                                        else\n                                        {\n                                                // MP陛 醱碟棻賊 橡擠曖 望 褻陝擊 虜萇棻..\n                                                print( \" spendMp:\" + spendMp);\n                                                obj.sendSetMpPacket(obj.getMp() - spendMp);\n                                        }\n                                }\n                        }\n                        if (t.getEventTerm() == -1)\n                                return;\n                        if (t.isOnEvent(currentT) == true)\n                        {\n                                if(obj.isMyControlObject())\n                                {\n                                        if(obj.getZPos() == 0)\n                                        {\n                                                local skill_level = sq_GetSkillLevel(obj, SKILL_ICEROAD);\n                                                local change_time = sq_GetLevelData(obj, SKILL_ICEROAD, SKL_LV_1, skill_level); // 雖樓衛除\n                                                local rate = sq_GetLevelData(obj, SKILL_ICEROAD, SKL_LV_3, skill_level); // 檜樓 徽\n                                                local movSpd = sq_GetLevelData(obj, SKILL_ICEROAD, SKL_LV_2, skill_level); // \n                                                sq_BinaryStartWrite();\n                                                        sq_BinaryWriteDword(change_time);    // 衛除\n\n                                                                        sq_BinaryWriteDword(rate);            // 徽\n                                                                sq_BinaryWriteDword(movSpd);        // 馬模纂 \n                                                // 嬴檜蝶 煎萄 撩 衛粽 蝶鑒擊 寡錫棻賊 蜃擎 瞳檜 綵唸 鼻鷓檜鼻縑 勘萼棻.\n                                                local skillLevel = sq_GetSkillLevel(obj, SKILL_ICEROAD_EX);\n                                                sq_BinaryWriteWord(skillLevel);\n                                                if (skillLevel &gt; 0)\n                                                {\n                                                        local prob = sq_GetLevelData(obj, SKILL_ICEROAD_EX, 4, skillLevel) / 10.0;// 鼻鷓檜鼻 綵唸曖 睦\n                                                                local asLevel = sq_GetLevelData(obj, SKILL_ICEROAD_EX, 5, skillLevel);    // 鼻鷓檜鼻 綵唸曖 溯漣\n                                                                local validTime = sq_GetLevelData(obj, SKILL_ICEROAD_EX, 6, skillLevel);    // 鼻鷓檜鼻 綵唸曖 衛除\n                                                                sq_BinaryWriteFloat(prob.tofloat());    // 睦\n\n                                                                                sq_BinaryWriteWord(asLevel);            // 溯漣\n                                                                                sq_BinaryWriteDword(validTime);            // 衛除\n                                                }\n                                                sq_SendCreatePassiveObjectPacket(obj, 24243, 0, 0, 0, 0, obj.getDirection());\n                                        }\n                                }\n                        }\n                }\n                }    \n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置被攻击属性伤害率\nfunction getImmuneTypeDamgeRate_ATMage(obj,damageRate, attacker)\n{\n        // 碳晦菅 錳剪葬 奢問曖 等嘐雖蒂 N%虜躑 馬模衛酈堅, 唳霜擊 嫡雖 彊蝗棲棻.\n        if(obj.getVar(\"firepillar\").size_vector() &gt; 0)\n        {\n                if(obj.getVar(\"firepillar\").get_vector(VECTOR_FLAG_2))\n                {\n                        if(attacker)\n                        {\n                                print( \" damageRate:\" + damageRate);\n                                local skillLevel = obj.sq_GetSkillLevel(SKILL_FIREPILLAR);\n                                local N = obj.sq_GetLevelData(SKILL_FIREPILLAR, 0, skillLevel); // 0.錳剪葬 還罹輿朝 馬模纂(%)\n                                // 錳剪葬 奢問檜塭賊..\n                                damageRate = damageRate - N;\n                                //damageRate = 10;\n                                print( \" convert damageRate:\" + damageRate);\n                        }\n                }\n        }\n                // 碳餌煎 犒衛縛 等嘐雖陛 2寡(1.5寡?) 菟橫除棻.    \n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"Character/ATMage/DieHard/ap_ATMage_DieHardSlowHeal.nut\")) //\n        {\n                //0. 問衛 嫡朝 等嘐雖 隸陛徽(%)\n                local increaseDamageRate = sq_GetIntData(obj, SKILL_DIEHARD, SKL_STATIC_INT_IDX_0); \n                //increaseDamageRate.tofloat() / 100.0;\n                damageRate = damageRate + increaseDamageRate;\n        }\n        return damageRate;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到被攻击的属性\nfunction getImmuneType_ATMage(obj,type, attacker)\n{\n        local immuneType = type;\n        return immuneType;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//使用技能前\nfunction useSkill_before_ATMage(obj, skillIndex, consumeMp, consumeItem, oldSkillMpRate)\n        {    \n        local bChangedMp = false;\n        print(\" consumpMp:\" + consumeMp + \" oldSkillMpRate:\" + oldSkillMpRate);\n        local appendage = obj.GetSquirrelAppendage(\"Character/ATMage/ManaBurst/ap_ATMage_ManaBurst.nut\");\n        if(appendage)\n        {\n                local isvalid = appendage.isValid();\n                if(isvalid)\n                {\n                        local skillLevel = obj.sq_GetSkillLevel(SKILL_MANABURST);\n                        local mpComsumeRate = sq_GetLevelData(obj, SKILL_MANABURST, SKL_LVL_COLUMN_IDX_0, skillLevel);\n                        local newMpRate = oldSkillMpRate.tofloat() * (100 + mpComsumeRate.tofloat()) / 100;\n                        print(\" newMpRate:\" + newMpRate);\n                        obj.setSkillMpRate(skillIndex, newMpRate.tofloat());\n                        bChangedMp = true;\n                                }        \n        }\n        if(obj.sq_GetSkillLevel(SKILL_EXPRESSION) &gt; 0)\n        {\n                local skillLevel = obj.sq_GetSkillLevel(SKILL_EXPRESSION);\n                local skillMpRate = obj.getSkillMpRate(skillIndex);\n                local mpComsumeRate = sq_GetLevelData(obj, SKILL_EXPRESSION, 0, skillLevel);\n                local newMpRate = skillMpRate.tofloat() * (100 - mpComsumeRate.tofloat()) / 100;\n                //print(\" expression consumeMp oldMpRate:\" + skillMpRate.tofloat() + \" skillIndex:\" + skillIndex);\n                //print(\" expression consumeMp newMpRate:\" + newMpRate.tofloat());\n                //print(\" expression consumeMp mpComsumeRate:\" + mpComsumeRate.tofloat());\n                obj.setSkillMpRate(skillIndex, newMpRate.tofloat());\n        }\n        print(\" now consumpMp:\" + obj.getSkillMpRate(skillIndex));\n        return true;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//使用技能后\nfunction useSkill_after_ATMage(obj, skillIndex, consumeMp, consumeItem, oldSkillMpRate)\n{\n        if(!obj)\n                return false;\n        obj.setSkillMpRate(skillIndex, oldSkillMpRate.tofloat());\n        print(\" after set consumpMp:\" + oldSkillMpRate);\n        return true;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//普攻强制施放技能\nfunction setEnableCancelSkill_ATMage(obj, isEnable)\n{\n        if(!obj)\n                return false;\n        if(!obj.isMyControlObject())\n                return false;\n        if(!isEnable)\n                return true;\n                        obj.setSkillCommandEnable(SKILL_ICE_SWORD, isEnable);\n\n        return true;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//是否是可以使用的道具 #可以获得物品栏为的物品ID\nfunction isUsableItem_ATMage(obj, itemIndex)\n{\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"Character/ATMage/DieHard/ap_ATMage_DieHardSlowHeal.nut\")) //\n        { // 碳餌煎 蝸煎辦 醞檜塭賊 犒啗翮 嬴檜蠱擊 噩 熱 橈蝗棲棻.\n                local isRecover = sq_IsItemRecover(itemIndex);\n                if(isRecover == true)\n                {\n                        return false;\n                }\n                if(itemIndex == 8)\n                { // 溯嘐曖 槳望\n                        return false;\n                }\n        }\n        //print( \" is use itemIndex:\" + itemIndex + \" return true\");\n        return true;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//发送设置HP包\nfunction sendSetHpPacket_ATMage(obj, hp, sendInstant)\n{\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"Character/ATMage/DieHard/ap_ATMage_DieHardSlowHeal.nut\")) //\n        {\n                if(obj.getHp() &lt; hp)\n                {\n                        //print(\" not send hp\");\n                        return false;\n                }\n        }\n        //print( \" go send hp\");\n        return true;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//发送设置MP包\nfunction sendSetMpPacket_ATMage(obj, mp, sendInstant)\n        {    \n        return true;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//当前技能效果 #接收技能效果包\nfunction onChangeSkillEffect_ATMage(obj, skillIndex, reciveData)\n{\n        if(!obj)\n                return;\n        if(skillIndex == SKILL_ICEROAD)\n        {\n                local skill = sq_GetSkill(obj, SKILL_ICEROAD);\n                skill.resetCurrentCoolTime();\n                        skill.setSealActiveFunction(true);    \n                local skill_level = sq_GetSkillLevel(obj, SKILL_ICEROAD);\n                obj.startSkillCoolTime(SKILL_ICEROAD, skill_level, -1);\n                local appendage = obj.GetSquirrelAppendage(\"Character/ATMage/IceRoad/ap_ATMage_IceRoad.nut\");\n                appendage.setValid(false);\n        }\n        else if(skillIndex == SKILL_DIEHARD)\n        {\n                if(reciveData.getSize() &gt; 0)\n                {\n                        local hp = reciveData.readDword(); // 翕晦 hp\n                        if(hp &gt; 0)\n                        {\n                                print(\" onchange:\" + hp);\n                                obj.setHp(hp, null, true);\n                        }\n                }\n        }\n        else if (skillIndex == SKILL_ELEMENTAL_CHANGE)\n        {\n                if (reciveData.getSize() &gt; 0)\n                {\n                        local element = reciveData.readByte();\n                        obj.setThrowElement(element);\n                        // 爾虞撩 籀葬\n                        local appendage = CNSquirrelAppendage.sq_GetAppendage(obj,\"Character/ATMage/MagicShield/ap_MagicShield.nut\");\n                        if(appendage)\n\n                                        setMagicShieldType(appendage, obj, obj.getThrowElement());    \n                }\n        }\n        else if(skillIndex == SKILL_TUNDRASOUL)\n        {\n                if (reciveData.getSize() &gt; 0)\n                {\n                        local mode = reciveData.readDword();\n                        local auraAppendage = 0;\n                        local appendage = CNSquirrelAppendage.sq_GetAppendage(obj, \"Character/ATMage/TundraSoul/ap_ATMage_TundraSoul.nut\");\n                        if(appendage)\n                        {\n                                auraAppendage = appendage.sq_getSquirrelAuraMaster(\"AuraTundraSoul\");\n\n\n                                                        if(mode == 1)            \n                                { // 氈朝匙擊 疏撿棲棻. (嬴辦塭)\n                                        appendage.sq_DeleteAppendages();\n                                }\n                                else if(mode == 0)\n                                { // 橈朝匙擊 麵撿棲棻. (嬴辦塭)\n                                        local range = obj.sq_GetIntData(SKILL_TUNDRASOUL , 0);// 0. 綵唸 鼻鷓檜鼻縑 勘葬朝 婁彰嬪\n                                        appendage.sq_AddSquirrelAuraMaster(\"AuraTundraSoul\",obj, obj, range, 18, 5, 0);\n                                }\n                        }\n                //CNSquirrelAppendage.sq_RemoveAppendage(obj, \"Character/ATMage/TundraSoul/ap_ATMage_TundraSoul.nut\");\n                }\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到13状态下的子状态\nfunction changeTrhowState_ATMage(obj, throwState)\n{\n        if (!obj) return false;\n        printc(\"changeTrhowState_ATMage\");\n        if (throwState == 3 &amp;&amp;\n                obj.getThrowIndex() == SKILL_ELEMENTAL_CHANGE)\n        {\n                // 陴徹餌 : 樓撩 嫦翕\n                obj.sq_IntVectClear();\n                obj.sq_IntVectPush(throwState);\n                obj.sq_IntVectPush(-1);\n                obj.sq_IntVectPush(obj.getThrowElement());\n                obj.sq_AddSetStatePacket(STATE_THROW, STATE_PRIORITY_USER, true);\n                return true;\n        }\n        return false;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//设置异常状态时\nfunction setActiveStatus_ATMage(obj, activeStatus, power)\n{\n        if (!obj) return 0;\n        local state = sq_GetState(obj);\n        if (state == STATE_ELEMENTAL_BUSTER)\n        {\n                // 陝撩橾隆 評煎 鼻鷓檜鼻檜 勘葬雖 彊擠 (縣溯詮驍 幗蝶攪)\n                //printc(\"state : STATE_ELEMENTAL_BUSTER\");\n                return 0;\n        }\n        return 1;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//播放移动声音\nfunction playMoveSound_ATMage(obj)\n{\n        //obj.sq_PlaySound(\"R_ICE_WALK\");\n        if(!obj)\n                return;\n        local result = CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"Character/ATMage/IceRoad/ap_ATMage_IceRoad.nut\");\n        if (result == true) // 嬴檜蝶煎萄蒂 麵堡擊 隆 嫦濠措模葬陛 夥荸棲棻.\n        {\n                obj.sq_PlaySound(\"R_ICE_WALK_LOOP\", SOUND_ID_MOVE);\n        }\n        else \n        {\n                obj.sq_PlayMoveSound();\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//播放前冲攻击声音\nfunction playDashAttackSound_Avenger(obj) // 대쉬사운드를 세팅하는 오버라이딩된 함수입니다..\n{\n        if(!obj) return 0;\n        if(!isGrowTypeAvenger(obj)) return 0; // 어벤져가 아니라면 또한 그려줄 필욘 없을겁니다..\n        if(isAvengerAwakenning(obj)) return 1; // 각성일땐 따로 대쉬사운드 세팅합니다..\n        return 0;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//重置刷新时 #死亡复活 #进入下一个房间\nfunction reset_ATMage(obj)\n{\n        if(!obj)                                     \n        return;        \n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//副本中重置状态时 #城镇中也会运行 #就相当于进入副本回到城镇都会运行\nfunction resetDungeonStart_ATMage(obj, moduleType, resetReason, isDeadTower, isResetSkillUserCount)\n{\n\n                if(!obj) return -1;    \n        local isReset = true; // 晦獄瞳戲煩 瞪睡 葬撢殮棲棻.\n        if (sq_GetCurrentModuleType() == MODULE_TYPE_WARROOM || sq_GetCurrentModuleType() == MODULE_TYPE_DEAD_TOWER)\n        {\n                // 葬撢曖 檜嶸陛 避朝檜嶸陛 嬴棲塭賊..\n                if (resetReason != REASON_DEATH)\n                {\n                        isReset = false; // 葬撢衛酈雖 彊蝗棲棻.\n                }\n        }\n        if(isReset)\n        { // 葬撢擊 撿棻賊..\n                local appendage = obj.GetSquirrelAppendage(\"Character/ATMage/IceRoad/ap_ATMage_IceRoad.nut\");\n                if(appendage)\n                {\n                        local skill = sq_GetSkill(obj, SKILL_ICEROAD);\n                        local isvalid = appendage.isValid();\n                        if(skill)\n                        {\n                                print(\" isSeal:\" + skill.isSealActiveFunction());\n                                if(!skill.isSealActiveFunction())\n                                {\n                                        skill.setSealActiveFunction(true);\n                                }\n                        }\n                        if(isvalid)\n                        {\n                                appendage.setValid(false);\n                        }\n                }\n                        obj.sq_RemoveSkillLoad(SKILL_HOLONG_LIGHT);    // 煬碳 UI 薯剪\n        }\n        return 1;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//画城镇，副本ui #城镇中和副本中都可以画 #图层较低\nfunction drawMainCustomUI_CreatorMage(obj)\n{\n        if (!obj)\n                return;\n        local sq_var = obj.getVar();\n\n        // 蝶鑒蝸煜\n        local hud_creator_b_gauge = sq_var.GetAnimationMap(\"hud_creator_b_gauge\", \"Character/Mage/CreatorAnimation/ui/hud_creator_b_gauge.ani\");\n        local hud_creator_b_select = sq_var.GetAnimationMap(\"hud_creator_b_select\", \"Character/Mage/CreatorAnimation/ui/hud_creator_b_select.ani\");\n        local skill_ui_index = 0;\n        local x = 626;\n        local y = 588;\n        local offset = 36;\n        // 斜葬晦\n                local hudCreatorAni = sq_var.GetAnimationMap(\"hud_creator_back\", \"Character/Mage/CreatorAnimation/ui/hud_creator_back.ani\");    \n        sq_DrawSpecificFrame(hudCreatorAni, x, y, false, 0, false, 1.0);\n        //\n        // 諄辦濠陛 氈擊 熱 氈戲嘎煎 檜夠縑憮 寡檣雖 嬴棋雖蒂 羹觼罹 \n        // 寡檜 嬴棋 唳辦 醴憮諦 ui蒂 橫鄹棲棻.\n        if (!IsInBattleCreator(obj))\n        {\n                local isEnable = isEnableCreatorBattleInUI();\n                if (!isEnable)\n                {\n                        unLockMouse(obj);\n                }\n                //return;\n        }\n        // 摹鷗 纔舒葬 斜葬晦\n        if (getCreatorSkillStateSkillIndex(obj) != -1)\n                {    \n                local type = getCreatorSkillStateSkillIndex(obj);\n                local skillmgr = obj.getSkillManager();\n                local slot = -1;\n                if (skillmgr)\n                {\n                        local index = getTypeSkillIndex(obj, type);\n                        slot = skillmgr.getSlotindex(index);\n                }\n                if (slot != -1)\n                        {    \n                        // 摹鷗雖 斜葬晦\n                        sq_AnimationProc(hud_creator_b_select);\n                        sq_drawCurrentFrame(hud_creator_b_select, x + (slot * offset), y, false);\n                }\n        }\n        // 啪檜雖 斜葬晦\n        local hud_creator_b_gauge = sq_var.GetAnimationMap(\"hud_creator_b_gauge\", \"Character/Mage/CreatorAnimation/ui/hud_creator_b_gauge.ani\");\n                // 樓撩蝶鑒 啪檜雖 斜葬晦 睡碟殮棲棻.    \n        local skillmgr = obj.getSkillManager();\n        if (!skillmgr)\n                return;\n        for (local i = CREATOR_TYPE_FLAME; i &lt; CREATOR_TYPE_MAX; i++)\n                {    \n                local slot = -1;\n                if (skillmgr)\n                {\n                        local index = getTypeSkillIndex(obj, i);\n                        slot = skillmgr.getSlotindex(index);\n                }\n                if (slot != -1)\n                {\n                        local appendage = getCreatorMageAppendageByType(obj, i);\n                        if (appendage)\n                        {\n                                local gaugeValue = 0;\n                                local max_gaugeValue = 0;\n                                max_gaugeValue = appendage.sq_var.get_vector(I_MAX_COUNT);\n                                gaugeValue = appendage.sq_var.get_vector(I_REMAIN_COUNT);\n\n\n                                                        local rate = gaugeValue.tofloat() / max_gaugeValue.tofloat();            \n                                local rgb = getCreatorTypeColor(obj, i);\n                                local alpha = sq_ALPHA(255);\n                                        hud_creator_b_gauge.setImageRate(rate, 1.0);    \n                                local gaugePosX = x - 87;\n                                sq_DrawSpecificFrameEffect_SIMPLE(hud_creator_b_gauge, gaugePosX + (slot * offset), y, 0, rgb, alpha, true);\n                        }\n                }\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//画副本中的ui #只能在副本中进行画ui\nfunction drawCustomUI_CreatorMage(obj)\n{\n        // 葆辦蝶斜椰 籀葬\n        if (!obj)\n                return;\n        if (!IsInBattleCreator(obj))\n        {\n                return;\n        }\n                // 醴憮斜葬晦    \n        // 醴憮 斜葬晦 睡碟殮棲棻.\n        local isLock = sq_IsClipCursor();\n        if (!isLock)\n        {\n                if (!sq_IsVisibleCursor())\n                {\n                        sq_SetVisibleCursor(true);\n                }\n                return;\n        }\n        if (sq_IsVisibleCursor())\n        {\n                sq_SetVisibleCursor(false);\n        }\n        local ani = obj.getVar().GetAnimationMap(\"NORMAL\", \n        \"Character/Mage/Effect/Animation/CreatorMagicSphere/normal.ani\"); // 橾奩醴憮\n        local usingSkillIndex = getCreatorSkillStateSkillIndex(obj);\n        if (usingSkillIndex == CREATOR_TYPE_DISTURB)\n        {\n                local stage = sq_GetObjectManagerStage(obj);\n                if (!stage)\n                        return;\n                                local control = stage.getMainControl();        \n                if (control.IsRBDown())\n                { // 萄煎辦橾隆 醴憮蒂 夥習棲棻.\n                        ani = obj.getVar().GetAnimationMap(\"THROW\", \n                        \"Character/Mage/Effect/Animation/CreatorMagicSphere/draw_cursor.ani\"); //\n                }\n                else\n                {\n                        ani = obj.getVar().GetAnimationMap(\"BLOCK\", \n                        \"Character/Mage/Effect/Animation/CreatorMagicSphere/block.ani\"); //\n                }\n        }\n        else if (usingSkillIndex == CREATOR_TYPE_GUARDIAN)\n        {\n                ani = obj.getVar().GetAnimationMap(\"GUARD\", \n                \"Character/Mage/Effect/Animation/CreatorMagicSphere/guard.ani\"); //\n        }\n        else if (usingSkillIndex == CREATOR_TYPE_ICE)\n        {\n                ani = obj.getVar().GetAnimationMap(\"ICE\", \n                \"Character/Mage/Effect/Animation/CreatorMagicSphere/icesphere.ani\"); //\n        }\n        else if (usingSkillIndex == CREATOR_TYPE_FLAME)\n        {\n                ani = obj.getVar().GetAnimationMap(\"FIRE\", \n\n\n                                        \"Character/Mage/Effect/Animation/CreatorMagicSphere/firesphere.ani\"); //        \n        }\n                else if (usingSkillIndex == CREATOR_TYPE_WIND)    \n        {\n                ani = obj.getVar().GetAnimationMap(\"WIND\", \n                \"Character/Mage/Effect/Animation/CreatorMagicSphere/wind.ani\"); //\n                        }        \n        local state = obj.getState();\n        if (state == STATE_ICESHIELD)\n                {    \n                ani = obj.getVar().GetAnimationMap(\"SHIELD\", \n                \"Character/Mage/Effect/Animation/CreatorMagicSphere/shield_cursor_dodge.ani\"); //\n        }\n        else if (state == STATE_FIREHURRICANE)\n        {\n                ani = obj.getVar().GetAnimationMap(\"HURRICANE\", \n                \"Character/Mage/Effect/Animation/CreatorMagicSphere/hurricane_cursor.ani\"); //\n        }\n        if (ani)\n        {\n                local posX = IMouse.GetXPos();\n                local posY = IMouse.GetYPos();\n                sq_AnimationProc(ani);\n                sq_drawCurrentFrame(ani, posX, posY, false);\n        }\n\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//画人物当前图层的ui #初始坐标为人物的偏移\n//isOver参数为true画身前 false画身后\nfunction drawAppend_CreatorMage(obj, isOver, x, y)\n{\n        if (!obj.isMyControlObject())\n                return 0;\n        return 0;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//准备画\nfunction prepareDraw_Avenger(obj)\n{\n        if (!obj) return;\n        if (isAvengerAwakenning(obj) == true)\n        { // isPriestFlow 葬欐高檜 true塭賊.. 陝撩檜 嬴棲堅 罹楝陛雖 褻勒檜 葬蝶 flow煎 緒螳撿 棻..\n                return S_FLOW_NORMAL;\n        }\n        return S_FLOW_PRIEST;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置当前ani的ani\nfunction setCurrentAnimation_Avenger(obj, animation)\n{\n        if (!obj) return;\n        if (!animation) return;\n        if (isAvengerAwakenning(obj))\n        { // 陝撩 菸蝶陛蛤樹 滲褐 塭賊 setcurrentanimation 腎朝 賅萇 animation擎 癱貲紫 褻瞰婦溼 楚斜蒂 螃衛霾棲棻..\n                if (animation)\n                {\n                        animation.setNeverApplyAnotherPlayersEffectAlphaRate(false);\n                        animation.setIsApplyAnotherPlayersEffectAlphaRate(false);\n                }\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置可攻击次数范围\nfunction getAttackCancelStartFrameSize_Priest(obj)\n{\n        local maxAttackNumber = obj.sq_GetAttackCancelStartFrameSize();\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true)\n                maxAttackNumber = 2;\n        return maxAttackNumber;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置攻击时 在哪一帧按下键时可以进入下一个子状态\nfunction getAttackCancelStartFrame_Priest(obj, index)\n{\n        if(!obj) return null;\n        local frm = 0;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true)\n    {\n        switch (index)\n        {\n            case 0:\n                frm = 7;\n                break;\n            case 1:\n                frm = 5;\n                break;\n        }\n    }else\n        frm = obj.sq_GetAttackCancelStartFrame(index);\n        return frm;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置攻击ani\nfunction getAttackAni_Priest(obj, index)\n{\n        if (!obj) return null;\n        local animation = obj.sq_GetAttackAni(index);\n        if (CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true)\n        animation = obj.sq_GetCustomAni(CUSTOM_ANI_PRIEST_JUPITERNORMALATKA_BODY + index);\n        return animation;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置默认攻击信息\nfunction getDefaultAttackInfo_Priest(obj, index)\n{\n        if (!obj) return null;\n        local attackInfo = obj.sq_GetDefaultAttackInfo(index);\n        if (CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true)\n                attackInfo = sq_GetCustomAttackInfo(obj, CUSTOM_ATTACK_PRIEST_JUPITERATTACK1 + index);\n        return attackInfo;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置跳跃ani\nfunction getJumpAni_Priest(obj)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_JUMP);\n        }\n        else {\n                ani = obj.sq_GetJumpAni();\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置跳跃升空帧\nfunction getJumpUpStartFrame_Avenger(obj)\n{\n        if (!obj) return null;\n        local index = 0;\n        if (isAvengerAwakenning(obj) == true)\n        {\n        index = 2;\n        }\n    else\n        index = obj.sq_getJumpUpStartFrame();\n        return index;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置跳跃下落帧\nfunction getJumpDownStartFrame_Avenger(obj)\n{\n        if (!obj) return null;\n        local index = 0;\n        if (isAvengerAwakenning(obj) == true)\n        {\n        index = 5;\n        }\n    else\n        index = obj.sq_getJumpDownStartFrame();\n        return index;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置跳跃落地帧\nfunction getJumpLandStartFrame_Avenger(obj)\n{\n        if (!obj) return null;\n        local index = 0;\n        if (isAvengerAwakenning(obj) == true)\n        {\n        index = 7;\n        }\n    else\n        index = obj.sq_getJumpLandStartFrame();\n        return index;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置跳跃攻击ani\nfunction getJumpAttackAni_Priest(obj)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITERHAMMERJUMPATK_BODY);\n        }\n        else {\n                ani = obj.sq_GetJumpAttackAni();\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置跳跃攻击信息\nfunction getJumpAttackAni_Priest(obj)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITERHAMMERJUMPATK_BODY);\n        }\n        else {\n                ani = obj.sq_GetJumpAttackAni();\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置前冲攻击ani\nfunction getDashAttackAni_Priest(obj)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITERHAMMERDASHATK_BODY);\n        }\n        else {\n                ani = obj.sq_GetDashAttackAni();\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置前冲攻击信息\nfunction getDashAttackInfo_Avenger(obj)\n{\n        if (!obj) return null;\n        local atk = null;\n        if (isAvengerAwakenning(obj) == true)\n        {\n                atk = sq_GetCustomAttackInfo(obj, CUSTOM_ATTACKINFO_AW_DASHATTACK);\n                local state = obj.sq_GetSTATE();\n                local power = obj.sq_getBonusRateWithPassive(SKILL_AVENGER_AWAKENING, state, SL_DASH_MAGIC_ATK, 1.0);\n                obj.sq_setCurrentAttackBonusRate(power);\n        }\n        else if (CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/metamorphosis/ap_metamorphosis.nut\"))//是半魔化狀態\n        {\n                atk = sq_GetCustomAttackInfo(obj, CUSTOM_ATTACK_PRIEST_METAMORPHOSISDASHATTACK);\n        }\n        return atk;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置前冲攻击停下帧\nfunction getDashAttackSlideStopFrame_Avenger(obj)\n{\n        if (!obj) return null;\n        local index = -1;\n        if (isAvengerAwakenning(obj) == true)\n        { // 橫漸螳 陝撩賅萄塭賊\n                index = 15;\n        }\n        else\n        {\n                index = obj.sq_getDashAttackSlideStopFrame();\n        }\n        return index;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置站立ani\nfunction getStayAni_Priest(obj)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_STAY);\n        }\n        else {\n                ani = obj.sq_GetStayAni();\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置行走ani\nfunction getMoveAni_Priest(obj)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_MOVE);\n        }\n        else {\n                ani = obj.sq_GetMoveAni();\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置死亡ani\nfunction getSitAni_Priest(obj)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_SIT);\n        }\n        else {\n                ani = obj.sq_GetSitAni();\n                }    \n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到被攻击伤害ani\nfunction getDamageAni_Priest(obj, index)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                if(index == 0)\n                        ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_DAMAGE1);\n                else if(index == 1)\n                        ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_DAMAGE2);\n        }\n        else {\n                ani = obj.sq_GetDamageAni(index);\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置从站立到倒地时的ani\nfunction getDownAni_Priest(obj)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_DOWN);\n        }\n        else {\n                ani = obj.sq_GetDownAni();\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置循环倒地ani\nfunction getOverturnAni_Priest(obj)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_OVERTURN);\n        }\n        else {\n                ani = obj.sq_GetOverturnAni();\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置城镇站立站街动作ani\nfunction getRestAni_Priest(obj)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_REST);\n        }\n        else {\n                ani = obj.sq_GetRestAni();\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置13状态下的 第一蓄力第二施放ani\nfunction getThrowChargeAni_Priest(obj, index)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n        switch (index)\n        {\n            case 0: ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_THROW1); break;\n            case 1: ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_PRAY1); break;\n            case 2: ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_DELIVER1); break;\n            case 3: ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_BLAST1); break;\n        }\n        }\n        else {\n                ani = obj.sq_GetThrowChargeAni(index);\n        }\n        return ani;\n}\nfunction getThrowShootAni_Priest(obj, index)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n        switch (index)\n        {\n            case 0: ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_THROW2); break;\n            case 1: ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_PRAY2); break;\n            case 2: ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_DELIVER2); break;\n            case 3: ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_BLAST2); break;\n        }\n        }\n        else {\n                ani = obj.sq_GetThrowShootAni(index);\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置前冲ani\nfunction getDashAni_Priest(obj)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_DASH);\n        }\n        else {\n                ani = obj.sq_GetDashAni();\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置捡到物品时的ani\nfunction getGetItemAni_Priest(obj)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_GETITEM);\n        }\n        else {\n                ani = obj.sq_GetGetItemAni();\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置创建buff时的ani 17状态下\nfunction getBuffAni_Priest(obj)\n{\n        if(!obj) return null;\n        local ani = null;\n        if(CNSquirrelAppendage.sq_IsAppendAppendage(obj, \"character/new_priest/jupiter/ap_jupiter.nut\") == true) {\n                ani = sq_GetCustomAni(obj, CUSTOM_ANI_PRIEST_JUPITER_QQ506807329_BUFF);\n        }\n        else {\n                ani = obj.sq_GetBuffAni();\n        }\n        return ani;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//角色状态的事件函数名 #俗称角色状态事件函数\n//设置状态时\nfunction onSetState_WaterCannon(obj, state, datas, isResetTimer)\n{\n        if (!obj) return;\n\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//设置状态后\nfunction onAfterSetState_fastmove(obj, state, datas, isResetTimer)\n{\n        if(!obj) return;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//ani的key flag标签事件\nfunction onKeyFrameFlag_WaterCannon(obj, flagIndex)\n{\n        if (!obj) return false;\n        return true;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//ani当前帧函数 #缔造者\nfunction onEnterFrame_FireHurricane(obj, frameIndex)\n{\n        if (!obj)\n                return;\n        local t = obj.getVar(\"state\").get_ct_vector(0);\n        local time = 0;\n        if(t)\n                time = t.Get();\n        local ani = sq_GetCurrentAnimation(obj);\n        if(!ani)\n                return;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//当前ani播放结束时\nfunction onEndCurrentAni_FirePillar(obj)\n{\n        if(!obj) return;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//按下技能键时\nfunction checkExecutableSkill_FirePillar(obj)\n{\n        if(!obj) return false;\n        local b_useskill = obj.sq_IsUseSkill(SKILL_FIREPILLAR);\n        if(b_useskill)\n        {\n                obj.sq_IntVectClear();\n                obj.sq_IntVectPush(SUB_STATE_FIREPILLAR_0); // substate세팅\n                obj.sq_AddSetStatePacket(STATE_FIREPILLAR, STATE_PRIORITY_IGNORE_FORCE, true);\n                return true;\n                }    \n        return false;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//被攻击前\n//复仇者函数\nfunction onBeforeDamage_fastmove(obj, attacker, boundingBox)\n{\n        if(!obj) return;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//其他职业函数\nfunction onBeforeDamage_FireHurricane(obj,attacker,boundingBox,isStuck)\n{\n        if(!obj) return;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//被攻击时\n//复仇者函数\nfunction onDamage_fastmove(obj, attacker, boundingBox)\n{\n    if(!obj) return;\n\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//其他职业函数\nfunction onDamage_FireHurricane(obj,attacker,boundingBox)\n{\n        if(!obj) return;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//被攻击后\n//复仇者函数\nfunction onAfterDamage_fastmove(obj, attacker, boundingBox)\n{\n        if(!obj) return;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//其他职业函数\nfunction onAfterDamage_FireHurricane(obj,attacker,boundingBox)\n{\n        if(!obj) return;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//攻击到前\n//复仇者函数\nfunction onBeforeAttack_fastmove(obj, damager, boundingBox)\n{\n        if(!obj) return;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//其他职业函数\nfunction onBeforeAttack_FireHurricane(obj,damager,boundingBox,isStuck)\n{\n        if(!obj) return;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//攻击到时\n//复仇者函数\nfunction onAttack_fastmove(obj, damager, boundingBox)\n{\n        if(!obj) return;\n                local subState = obj.getSkillSubState();    \n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//其他职业函数\nfunction onAttack_BrokenArrow(obj, damager, boundingBox, isStuck)\n{\n        if(!obj) return;\n        local subState = obj.getSkillSubState();\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//攻击到后\n//复仇者函数\nfunction onAfterAttack_fastmove(obj, damager, boundingBox)\n{\n        if(!obj) return 0;\n        return 1;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//其他职业函数\nfunction onAfterAttack_FireHurricane(obj,damager,boundingBox,isStuck)\n{\n        if(!obj) return 0;\n        return 1;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//结束当前状态时\nfunction onEndState_fastmove(obj, new_state)\n{\n        if(!obj) return;\n        if(new_state != STATE_FASTMOVE)\n        {\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//定时时钟时间\nfunction onTimeEvent_CrystalAttack(obj, timeEventIndex, timeEventCount)\n{    \n        if(!obj) return true;\n\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//技能效果包\nfunction onChangeSkillEffect_FireHurricane(obj, skillIndex, reciveData)\n{\n        if (!obj) return;\n\n        local subState = obj.getSkillSubState();\n        if (substate == SUB_STATE_FIREHURRICANE_0)\n        {\n\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//传递\nsq_BinaryStartWrite();\nsq_BinaryWriteBool();\nsq_BinaryWriteFloat();\nsq_BinaryWriteWord();\nsq_BinaryWriteByte();\nsq_BinaryWriteDword();\n\n_________________________________________________________________________________________________________________________________________________________\n\n//人物传递\nobj.sq_StartWrite();\nobj.sq_WriteBool();\nobj.sq_WriteFloat();\nobj.sq_WriteWord();\nobj.sq_WriteByte();\nobj.sq_WriteDword();\n\n_________________________________________________________________________________________________________________________________________________________\n\nsq_SendChangeSkillEffectPacket(obj, SKILL_ATFIGHTER_GLANCETHEHOST);//发送\n\n_________________________________________________________________________________________________________________________________________________________\n\n//接收\nreciveData.readBool();\nreciveData.readByte();\nreciveData.readWord();\nreciveData.readDword();\nreciveData.readFloat();\n\n_________________________________________________________________________________________________________________________________________________________\n\n//被动 #组队双方运行\nfunction onProc_WaterCannon(obj)\n{\n        if (!obj) return;\n\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//被动 #组队我自己运行\nfunction onProcCon_FireHurricane(obj)\n{\n        if(!obj) return;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到我创建的对象\nfunction onCreateObject_PowerOfDarkness(obj, createObject)\n        {    \n        local sq_var = obj.getVar();  \n        local cuid = sq_GetUniqueId(createObject);\n        local circleIndex = sq_var.getInt(POD_VAR_CIRCLE_INDEX);\n                if(cuid == circleIndex) {    \n                local group = sq_GetGroup(createObject);\n                local uid  = sq_GetUniqueId(createObject);\n                sq_var.setObject(POD_VAR_CIRCLE_OBJECT, createObject);\n                sq_var.setInt(POD_VAR_CIRCLE_OBJECT_GROUP, group);\n                sq_var.setInt(POD_VAR_CIRCLE_OBJECT_UID, uid);\n        }\n}\nlocal circleIndex = sq_SendCreatePassiveObjectPacket(obj,24107, 0, 172, 2, 97,obj.getDirection());\n\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到设置视角坐标\nfunction getScrollBasisPos_ElementalBuster(obj)\n{\n        if (!obj) return;\n        local subState = obj.getSkillSubState();\n        if (obj.isMyControlObject())\n        {\n                local destX = sq_GetDistancePos(obj.getXPos(), obj.getDirection(), 300);\n                local xPos = obj.getXPos();\n                local var = obj.getVar();\n                local isLast  = var.getBool(VAR_ELEMENTAL_BUSTER_IS_LAST);\n                if (subState == SUB_STATE_ELEMENTAL_BUSTER_START)\n                {\n                        local stateTimer = obj.sq_GetStateTimer();\n                        xPos = sq_GetUniformVelocity(xPos, destX, stateTimer, 300);\n                }\n                else if (isLast)\n                {\n                        local stateTimer = obj.sq_GetStateTimer();\n                        xPos = sq_GetUniformVelocity(destX, xPos, stateTimer, 300);\n                }\n                else\n                {\n                        xPos = destX;\n                }\n                obj.sq_SetCameraScrollPosition(xPos, obj.getYPos(), 0);\n                return true;\n        }\n        return false;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//结束当前map时\nfunction onEndMap_ElementalRain(obj)\n{\n        if (obj.sq_IsMyControlObject())\n        {\n\n\n\n                                        local ballCount = obj.getMyPassiveObjectCount(24233);            \n                printc(\"ballCount\" + ballCount);\n                for (local i = 0; i &lt; ballCount ; ++i) \n                { \n                        local magicBall = obj.getMyPassiveObject(24233,i)\n                        if (!magicBall)\n                                continue;\n                        if (obj.sq_IsMyControlObject())\n                        {\n                                print(\"onEndMap_ElementalRain\");\n                                sq_SendDestroyPacketPassiveObject(magicBall);\n                        }\n                }\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//po事件函数名 #特效nut的事件函数\n//被创建时设置自定义数据 #可以得到传递过来的数据\nfunction setCustomData_po_ATMagicBallLight(obj, receiveData)\n{\n        if(!obj) return;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//传递\nsq_BinaryStartWrite();\nsq_BinaryWriteBool();\nsq_BinaryWriteFloat();\nsq_BinaryWriteWord();\nsq_BinaryWriteByte();\nsq_BinaryWriteDword();\n\n_________________________________________________________________________________________________________________________________________________________\n\n//人物传递\nobj.sq_StartWrite();\nobj.sq_WriteBool();\nobj.sq_WriteFloat();\nobj.sq_WriteWord();\nobj.sq_WriteByte();\nobj.sq_WriteDword();\n\n_________________________________________________________________________________________________________________________________________________________\n\n//接收\nreciveData.readBool();\nreciveData.readByte();\nreciveData.readWord();\nreciveData.readDword();\nreciveData.readFloat();\n\n_________________________________________________________________________________________________________________________________________________________\n\n//设置状态时\nfunction setState_po_ATPieceOfIceCore(obj, state, datas)\n{\n        if(!obj) return;\n        if(state == PIECE_OF_ICE_CORE_STATE_DAMAGE)\n        {\n                local ani = obj.getCurrentAnimation();\n\n                                local var = obj.getVar();        \n                                        if(ani) {            \n                        local currentIndex = sq_GetVectorData(datas, 0) + 3;\n                        ani.setCurrentFrameWithChildLayer(currentIndex);\n                                }        \n                local timer = var.get_ct_vector(0);\n                var.setInt(PIECE_OF_ICE_CORE_VAR_SHAKE_END_TIME, timer.Get() + 50); \n                sq_SetMyShake(obj,2,80);\n                }    \n        else if(state == PIECE_OF_ICE_CORE_STATE_END)\n\n\n                                {            \n                                        local ani = obj.getCurrentAnimation();            \n                        if(ani)    \n                        ani.setCurrentFrameWithChildLayer(10); // 마지막 프레임\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到传递过来的数据\nsq_GetVectorData(datas, 0);\n\n_________________________________________________________________________________________________________________________________________________________\n\n//结束当前ani时\nfunction onEndCurrentAni_po_ATConcentrateExpSmall(obj)\n{\n        if (!obj) return;\n        if (obj.isMyControlObject()) {\n                sq_SendDestroyPacketPassiveObject(obj);\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//攻击到时\nfunction onAttack_po_ATIceManMagicCircle(obj, damager, boundingBox, isStuck)\n{\n        if(!obj)\n                return 0;\n        local pChr = obj.getTopCharacter();\n        if(!pChr)\n                return 0;\n        local active_damager = sq_GetCNRDObjectToActiveObject(damager);\n        if(!active_damager)\n                return 0;\n        local passiveState = obj.getVar(\"state\").get_vector(0);\n        if(passiveState == PASSIVEOBJ_SUB_STATE_1)\n        {\n                local rand = sq_getRandom(0, 100); \n                local rate = obj.getVar(\"freezeRate\").get_vector(0);\n                print(\" rate:\" + rate + \" rand\" + rand);\n                // 이속확율이 넘어가야 이속감소 어펜디지를 걸어줍니다..\n                if(rand &lt;= obj.getVar(\"freezeRate\").get_vector(0))\n                        {    \n                        CNSquirrelAppendage.sq_AppendAppendage(damager, pChr, SKILL_ICEMAN, \n                        true, \"Character/ATMage/IceMan/ap_ATIceManMagicCircle.nut\", true);\n                }\n        }\n        return 0;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//攻击后时\nfunction onAfterAttack_po_ATWaterCannon(obj, damager, boundingBox, isStuck)\n{\n        if (!obj)\n                return 0;\n        if(obj.isMyControlObject())\n        {\n\n                        sq_SendDestroyPacketPassiveObject(obj);    \n        }\n        return 0;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//被动\nfunction procAppend_po_ATPieceOfIceCore(obj)\n{\n        if(!obj) return;\n                local var = obj.getVar();    \n\n                                local timer = var.get_ct_vector(0);            \n        local shakeEndTime = var.getInt(PIECE_OF_ICE_CORE_VAR_SHAKE_END_TIME);\n        local shakeValue = 0;\n        if(timer.Get() &lt; shakeEndTime &amp;&amp; obj.getState() != PIECE_OF_ICE_CORE_STATE_END)\n                shakeValue = (sq_GetShuttleValue(0, 6,sq_GetObjectTime(obj),100)-3);\n        local x = var.getInt(PIECE_OF_ICE_CORE_VAR_START_X) + shakeValue;\n        local y = obj.getYPos();\n        local z = sq_GetShuttleValue(55, 65,sq_GetObjectTime(obj),1200);\n        sq_SetCurrentPos(obj, x, y, z);\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//ani的key flag标签\nfunction onKeyFrameFlag_po_ATPieceOfIceCore(obj, flagIndex)\n{\n        if(!obj)\n                return false;\n        if(flagIndex == 1)\n        {\n                sq_SetMyShake(obj,3,100);\n        }\n        if(flagIndex == 2)\n        {\n\n             obj.sendStateOnlyPacket(PIECE_OF_ICE_CORE_STATE_END);        \n        }\n                return true;    \n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//返回值应用：返回true 运行成功， 返回false 运行不成功 会多运行几次\n//时钟事件\nfunction onTimeEvent_po_ATHolongLight(obj, timeEventIndex, timeEventCount)\n        {    \n        if(!obj)\n                return false;\n        if(obj.isMyControlObject() &amp;&amp; timeEventIndex == 0)\n                {    \n                if(obj.getState() == HOLONG_LIGHT_STATE_BUFF) {\n                        obj.sendStateOnlyPacket(HOLONG_LIGHT_STATE_DESTROY);\n                                local mage = sq_ObjectToSQRCharacter(obj.getTopCharacter());    \n                        if (mage)\n\n                                        mage.sq_RemoveSkillLoad(SKILL_HOLONG_LIGHT);    \n                }\n                return true; // true면 콜백 중단\n        }\n        else if( timeEventIndex == 1 )\n        {\n                obj.sendStateOnlyPacket(HOLONG_LIGHT_STATE_EXPLOSION);\n        }\n                return false;    \n} \n\n_________________________________________________________________________________________________________________________________________________________\n\n//返回值的应用 ：返回false 代表此时钟没有运行成功  true代表此时钟运行成功\n//运行不成功可能会造成此函数一直运行\n//当前技能效果\nfunction onChangeSkillEffect_po_ATIceChakramSmallIceRing(obj, skillIndex, reciveData)\n{\n        if(!obj) return;\n                if(skillIndex != SKILL_ICECHAKRAM) return;    \n                local pChr = obj.getTopCharacter();    \n                if(!pChr) return;    \n        local changeAngle = reciveData.readFloat();\n        //print( \" changeAngle:\" + changeAngle);\n        local t = obj.getVar(\"sr\").get_ct_vector(0);\n        if(!t)\n                return;\n        t.Reset();\n        t.Start(10000,0);\n        //print( \" changeAngle:\" + changeAngle);\n                //local bombingStartAngle_ = obj.getVar(\"sr\").get_vector(1)\n                //local bombingChangeAngle_ = obj.getVar(\"sr\").get_vector(0);\n        obj.getVar(\"sr\").set_vector(0, changeAngle.tointeger());\n        local currentAng = obj.getVar(\"angle\").get_vector(0);\n        obj.getVar(\"sr\").set_vector(1, currentAng);\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//传递\nsq_BinaryStartWrite();\nsq_BinaryWriteBool();\nsq_BinaryWriteFloat();\nsq_BinaryWriteWord();\nsq_BinaryWriteByte();\nsq_BinaryWriteDword();\n\n_________________________________________________________________________________________________________________________________________________________\n\n//人物传递\nobj.sq_StartWrite();\nobj.sq_WriteBool();\nobj.sq_WriteFloat();\nobj.sq_WriteWord();\nobj.sq_WriteByte();\nobj.sq_WriteDword();\n\n_________________________________________________________________________________________________________________________________________________________\n\nsq_SendChangeSkillEffectPacket(obj, SKILL_ATFIGHTER_GLANCETHEHOST);//发送\n\n_________________________________________________________________________________________________________________________________________________________\n\n//接收\nreciveData.readBool();\nreciveData.readByte();\nreciveData.readWord();\nreciveData.readDword();\nreciveData.readFloat();\n\n_________________________________________________________________________________________________________________________________________________________\n\n//我创建的对象被破坏时\nfunction onDestroyObject_po_ATHolongLight(obj, destroyObj)\n{\n        local parentObj = obj.getParent();\n        parentObj = sq_ObjectToSQRCharacter(parentObj);\n                if(!parentObj || isSameObject(parentObj,destroyObj)) { //부모 객체가 파괴되면 사라짐     \n                obj.sendStateOnlyPacket(HOLONG_LIGHT_STATE_DESTROY);\n                }    \n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//攻击到时可设置攻击效果ani #不支持带als的ani\nfunction getCustomHitEffectFileName_po_ATBrokenArrow(obj, isAttachOnDamager)\n{\n        return \"PassiveObject/Character/Mage/Animation/ATBrokenArrow/02_arrowboom_dodge.ani\";\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到被攻击方向\nfunction getHitDirection_po_ATConcentrateExpSmall(obj, damager)\n{\n        if (!obj) return 0;\n        return sq_GetOppositeDirection(obj.getDirection());\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//我自己被破坏销毁时\nfunction destroy_po_ATIceChakramLarge(obj)\n{\n\n                sq_RemoveParticle(\"PassiveObject/Character/Mage/Particle/ATIceChakramDust.ptl\", obj);    \n        obj.stopSound(2711);\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//重置时 #没测试\nfunction reset_po_ATDarknessMantle(obj)\n{\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//ap事件函数名 #附加appendage的事件函数名\n//ap增加效果ani\nfunction sq_AddEffect(appendage)\n{\n        appendage.sq_AddEffectBack(\"Character/Common/Animation/BusterMode/buster_loop_back_normal.ani\");//背后\n        appendage.sq_AddEffectFront(\"Character/Common/Animation/BusterMode/buster_loop_front_normal.ani\");//身前\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\nappendage.sq_DeleteEffectFront();//删除身前ani\nappendage.sq_DeleteEffectBack();//删除身后ani\nlocal ani = appendage.sq_GetFrontAnimation(0);//得到身前的ani\nlocal ani = appendage.sq_GetBackAnimation(0);//得到身后的ani\n\n_________________________________________________________________________________________________________________________________________________________\n\n//是否是结束\nlocal isEnd = sq_IsEnd(ani);\nif(isEnd)\n{\n        appendage.setValid(false);//销毁ap\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//一开始时的设置\nfunction sq_AddFunctionName(appendage)\n{\n        appendage.sq_AddFunctionName(\"onStart\", \"onStart_appendage_IceCrash\")\n}\n\n\nfunction onStart_appendage_IceCrash(appendage)\n{\n        if(!appendage) {\n                return;\n        }\n        local parentObj = appendage.getParent();\n        local sourceObj = appendage.getSource();\n\n\n        if(!sourceObj || !parentObj) {\n                appendage.setValid(false);\n                return;\n                }    \n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//进入下一个map时\nfunction sq_AddFunctionName(appendage)\n{\n        appendage.sq_AddFunctionName(\"onStartMap\", \"onStartMap_appendage_common_burster\")\n}\n\nfunction onStartMap_appendage_common_burster(appendage)\n{\n        if(!appendage)\n                return;\n        local obj = appendage.getParent();\n        if(!obj)\n        {\n                appendage.setValid(false);\n                return;\n        }\n        local validT = appendage.getAppendageInfo().getValidTime();\n        local useTime = appendage.getTimer().Get();\n        local remainT = validT - useTime;\n        print(\" remain validT:\" + remainT);\n        if (obj.isMyControlObject())\n        {\n                if (remainT &gt; 0)\n                {\n                        sq_flashScreen(obj, 0, remainT, 300, 150, sq_RGB(0,0,0), GRAPHICEFFECT_NONE, ENUM_DRAWLAYER_BOTTOM);\n                }\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//ap销毁结束时\nfunction sq_AddFunctionName(appendage)\n{\n        appendage.sq_AddFunctionName(\"onEnd\", \"onEnd_appendage_atmage_bodyeffect\")\n}\nfunction onEnd_appendage_PushOut(appendage)\n{\n        if(!appendage) {\n                return;\n                }    \n        local parentObj = appendage.getParent();\n\n\n        if(!parentObj) {\n                appendage.setValid(false);\n                return;\n\n                                }            \n        if (parentObj.getState() == STATE_HOLD) {\n                appendage.setValid(false);\n                parentObj.sendStateOnlyPacket(STATE_STAND);\n        }\n        // TODO : x축 우선 체크 할것. 지금은 y축으로 내려와 버려서 연속기가 안됨\n        //local ao = sq_GetCNRDObjectToActiveObject(parentObj);\n        //if(ao &amp;&amp; sq_IsMyControlObject(ao) &amp;&amp; !ao.isMovablePos(ao.getXPos(),ao.getYPos())) {\n                //sq_SimpleMoveToNearMovablePos(ao,100); // 이동불가 지역에 있다면 이동가능지역으로 이동\n        //}\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//ap销毁结束时判断是否可结束\nfunction sq_AddFunctionName(appendage)\n{\n        appendage.sq_AddFunctionName(\"isEnd\", \"isEnd_appendage_atmage_bodyeffect\")\n}\n\nfunction isEnd_appendage_avenger_awakening(appendage)\n{\n        local T = appendage.getTimer().Get();\n        if(appendage.sq_var.size_vector() != (I_AVENGER_AWAKENING_VALID + 1)) {\n                return true;\n        }\n        local maxT = appendage.sq_var.get_vector(I_AVENGER_AWAKENING_TIME);\n        local doomshp = appendage.sq_var.get_vector(I_DOOMS_HP); // 변신한 어벤져의 hp값\n        if(T &gt;= maxT || doomshp &lt;= 0) { // 시간이 다 됐거나 둠스가디언 hp가 다 닳았다면.. 끝이다..\n        //if(T &gt;= maxT) {\n                return true;\n        }\n        return false;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//在ap中进行判断才会运行 isEnd 函数\nappendage.isEnd();\n\n_________________________________________________________________________________________________________________________________________________________\n\n//有效时间结束时\nfunction sq_AddFunctionName(appendage)\n{    \n    appendage.sq_AddFunctionName(\"onVaildTimeEnd\", \"onVaildTimeEnd_appendage_atmage_elemental_change\")\n}\nfunction onVaildTimeEnd_appendage_atmage_elemental_change(appendage)\n{\n        if(!appendage)\n\n\n                                return;        \n        local parentObj = appendage.getParent();\n        local sourceObj = appendage.getSource();\n\n\n        if(!sourceObj || !parentObj) {\n                appendage.setValid(false);\n                return;\n                }    \n        local mage = sq_ObjectToSQRCharacter(parentObj);\n        if(mage)\n\n\n                                mage.setThrowElement(ENUM_ELEMENT_NONE);        \n        // 보호막형성 처리\n        local appendage = CNSquirrelAppendage.sq_GetAppendage(mage,\"Character/ATMage/MagicShield/ap_MagicShield.nut\");\n        if(appendage)\n                setMagicShieldType(appendage, mage, mage.getThrowElement());\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//被动\nfunction sq_AddFunctionName(appendage)\n{\n        appendage.sq_AddFunctionName(\"proc\", \"proc_appendage_atmage_diehard\")\n}\n\n\nfunction proc_appendage_atmage_diehard(appendage)\n{\n        if(!appendage) {\n                return;\n        }\n        local parentObj = appendage.getParent();\n        if(!parentObj)\n        {\n                appendage.setValid(false);\n                return;\n        }\n\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//附加对象被攻击时\nfunction sq_AddFunctionName(appendage)\n{\n    appendage.sq_AddFunctionName(\"onDamageParent\", \"onDamageParent_appendage_MagicShield\")    \n}\n\nfunction onDamageParent_appendage_MagicShield(appendage ,attacker, boundingBox, isStuck) \n\n                {        \n        if (!appendage) {\n\n\n                                return;        \n        }\n                local parentObj = appendage.getParent();    \n        parentObj = sq_GetCNRDObjectToSQRCharacter(parentObj);\n        if (!parentObj) {\n                appendage.setValid(false);\n                return;\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//附加对象攻击时 #这里也包括附加对象创建的特效\nfunction sq_AddFunctionName(appendage)\n{\n        appendage.sq_AddFunctionName(\"onAttackParent\", \"onAttackParent_appendage_common_burster\")\n}\nfunction onAttackParent_appendage_common_burster(appendage, realAttacker, damager, boundingBox, isStuck)\n{\n        if(!appendage) {\n                return;\n        }\n        // 버스터모드로 쳤다면..\n        if (appendage.isValid())\n        {\n                local centerX = sq_GetCenterXPos(boundingBox);\n                local centerZ = sq_GetCenterZPos(boundingBox);\n                local posY = damager.getYPos();\n                local hitEffAni = sq_CreateAnimation(\"\",\"Character/Common/Animation/BusterMode/buster_hit_back_normal1.ani\");\n                local hitBackEffObj = sq_CreatePooledObject(hitEffAni, true);\n                hitBackEffObj.setCurrentPos(centerX, posY - 1, centerZ);\n                sq_AddObject(realAttacker, hitBackEffObj, OBJECTTYPE_DRAWONLY, false);\n                local hitFrontEffAni = sq_CreateAnimation(\"\",\"Character/Common/Animation/BusterMode/buster_hit_front_dodge.ani\");\n                local hitFrontEffObj = sq_CreatePooledObject(hitFrontEffAni, true);\n                hitFrontEffObj.setCurrentPos(centerX, posY + 1, centerZ);\n                sq_AddObject(realAttacker, hitFrontEffObj, OBJECTTYPE_DRAWONLY, false);\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//附加对象设置hp时\nfunction sq_AddFunctionName(appendage)\n{\n        appendage.sq_AddFunctionName(\"onSetHp\", \"onSetHp_appendage_avenger_awakening\")\n}\nfunction onSetHp_appendage_avenger_awakening(appendage, hp, attacker)\n{\n        local obj = appendage.getParent();\n        if(appendage.sq_var.size_vector() != (I_AVENGER_AWAKENING_VALID + 1)) {\n                return -1;\n        }\n        if(attacker &amp;&amp; obj &amp;&amp; obj.isEnemy(attacker))\n                {    // 적에 의한\n                local org_hp = hp;\n                if (org_hp &lt;= 0) {\n                        org_hp = 1;\n                        appendage.sq_var.set_vector(I_DOOMS_HP, 0);\n                }\n                return org_hp;\n        }\n        return -1;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//设置被攻击的伤害率\nfunction sq_AddFunctionName(appendage)\n{\n        appendage.sq_AddFunctionName(\"getImmuneTypeDamageRate\", \"getImmuneTypeDamageRate_appendage_MagicShield\")\n}\n\nfunction getImmuneTypeDamageRate_appendage_MagicShield(appendage, damageRate, attacker)\n\n                {        \n        if (!appendage)\n                return damageRate;\n                local parentObj = appendage.getParent();    \n        parentObj = sq_GetCNRDObjectToSQRCharacter(parentObj);\n        if (!parentObj) {\n                appendage.setValid(false);\n                return damageRate;\n        }\n        local var = appendage.getVar();\n        if (!var)\n\n                        return damageRate;    \n        local type = parentObj.getThrowElement();\n        // 수속성 : 데미지 일정 횟수 완전 방어\n        if (type == ENUM_ELEMENT_WATER)\n\n\n\n                                        return 0;            \n                        local type = parentObj.getThrowElement();        \n        // 레벨인포로 데미지율이 조정됨.\n        local skill_level = parentObj.sq_GetSkillLevel(SKILL_MAGIC_SHIELD);\n\n\n                                local decreaseRate = parentObj.sq_GetLevelData(SKILL_MAGIC_SHIELD, 1, skill_level); // 1. 데미지 감소율(%)            \n        damageRate = damageRate - decreaseRate;\n        return damageRate;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//源对象的ani key flag标签\nfunction sq_AddFunctionName(appendage)\n{\n    appendage.sq_AddFunctionName(\"onSourceKeyFrameFlag\", \"onSourceKeyFrameFlag_appendage_mage_electricrabbit\");    \n}\n\nfunction onSourceKeyFrameFlag_appendage_mage_electricrabbit(appendage,flagIndex)\n{\n        if(!appendage) return;\n\n        local obj = appendage.getParent();\n        if(obj)\n        {\n        obj = sq_GetCNRDObjectToSQRCharacter(obj);\n        obj.getVar(\"debugnew2\").push_vector(flagIndex);\n        obj.getVar(\"debugnew2\").push_vector(attacker.getXPos());\n        }\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//附加对象创建的对象被破坏时\nfunction sq_AddFunctionName(appendage)\n{\n        appendage.sq_AddFunctionName(\"onDestroyObject\", \"onDestroyObject_appendage_grab_icemagic\")\n}\n\nfunction onDestroyObject_appendage_grab_icemagic(appendage, destroyObj)\n{\n        if(!appendage)\n                return true;\n        if (destroyObj == appendage.sq_GetSourceChrTarget())\n        {\n                appendage.setValid(false);\n        }\n        return true;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//可以画出附加对象图层的动画ani\n\nfunction sq_AddFunctionName(appendage)\n{\n                appendage.sq_AddFunctionName(\"drawAppend\", \"drawAppend_appendage_MagicShield\")    \n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//参数x y为我自己的位置\n//isOver参数为true画身前 false画身后\n//isFlip判断是否翻转\nfunction drawAppend_appendage_MagicShield(appendage, isOver, x, y, isFlip)\n{\n        if (!appendage) {\n                return;\n        }\n        local obj = appendage.getParent();\n        if (!obj) {\n                appendage.setValid(false);\n                return;\n        }\n        local var = appendage.getVar();\n        local backAni = var.getAnimation(VAR_MAGIC_SHIELD_BACK_ANI);\n        local frontAni = var.getAnimation(VAR_MAGIC_SHIELD_FRONT_ANI);\n\n                        if (frontAni &amp;&amp; isOver) {        \n                sq_AnimationProc(frontAni);\n\n                                sq_drawCurrentFrame(frontAni, x, y, isFlip);        \n                }    \n        else if (backAni &amp;&amp; !isOver) {\n                sq_AnimationProc(backAni);\n                sq_drawCurrentFrame(backAni, x, y, isFlip);\n        }\n\n_________________________________________________________________________________________________________________________________________________________\n\n//自定义ani\n    local Ani = var.GetAnimationMap(\"flashcutbg_01\", \"character/swordman/effect/animation/flashcut/flashcutbg_01.ani\");\n\n                sq_AnimationProc(Ani);\n                sq_drawCurrentFrame(Ani, 400, y, isFlip);\n}\n\n\n_________________________________________________________________________________________________________________________________________________________\n\n//画附加对象的ui图层是否继续画\nfunction sq_AddFunctionName(appendage)\n{\n        appendage.sq_AddFunctionName(\"isDrawAppend\", \"isDrawAppend_appendage_atmage_tundra_cs\")\n}\nfunction isDrawAppend_appendage_atmage_tundra_cs(appendage)\n{\n        local obj = appendage.getParent();\n        if(!obj) {\n                appendage.setValid(false);\n                return false;\n        }\n        local mode = appendage.getVar(\"mode\").get_vector(0);\n        if(sq_IsValidActiveStatus(obj, ACTIVESTATUS_FREEZE) || mode == MODE_FREEZE)\n        {\n                return false;\n        }\n        return true;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//ap改变状态时 #如果设置相同状态则不会运行 #只有在设置不同状态时才会运行\nfunction sq_AddFunctionName(appendage)\n{\n        appendage.sq_AddFunctionName(\"onChangeState\", \"onChangeState_execution\");\n}\nfunction onChangeState_execution(appendage, oldState, newState, datas)\n        {    \n        if(!appendage) return;\n        appendage.sq_var.setBool(EXC_VAR_MOVE_ACTIVE,true);\n        appendage.sq_var.setInt(EXC_VAR_CURRENT_STATE,newState);  //현재 스테이트 : 부모의 키프레임값\n        // 잡기 불가적은 뒤로 던지기 전에 풀어준다.\n        if(newState &gt;= 7 &amp;&amp; !isGrabableParent(appendage))\n        {\n                appendage.setValid(false);\n                return;\n        }\n        setNewState_execution(appendage, oldState ,newState, false);\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//ap 发送状态\nappendage.setState(flagIndex,sq_GetGlobalIntVector());\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到附加对象被攻击时的伤害数值 #就是获取被攻击时打了多少伤害但是组队会不运行\nfunction sq_AddFunctionName(appendage)\n{\n        appendage.sq_AddFunctionName(\"onApplyHpDamage\", \"onApplyHpDamage_appendage_atmage_tundra_cs\")\n}\nfunction onApplyHpDamage_appendage_atmage_tundra_cs(appendage, newHpDamage, attacker)\n{\n        local obj = appendage.getParent();\n        if(!obj)\n                return newHpDamage;\n        local damage = newHpDamage;\n        if(sq_IsValidActiveStatus(obj, ACTIVESTATUS_FREEZE))\n        {\n\n\n                                local frozenAddDamageRate = appendage.getVar(\"skl\").get_vector(4);        // 4.얼어있는 적 추가 데미지\n                local addDamage = newHpDamage.tofloat() * frozenAddDamageRate.tofloat() / 100.0;\n                print(\" addDamage:\" + addDamage);\n                damage = damage + addDamage.tointeger();\n        }\n        return damage;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//未知 #hearthings\nfunction sq_AddFunctionName(appendage)\n{\n        //appendage.sq_AddFunctionName(\"hearthings\", \"proc_appendage_priest_scythe_mastery\")\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//准备画？\nfunction sq_AddFunctionName(appendage)\n{\n        appendage.sq_AddFunctionName(\"prepareDraw\", \"prepareDraw_appendage_atmage_darknessmantle_effect\")\n}\n\nfunction prepareDraw_appendage_atmage_darknessmantle_effect(appendage)\n{\n        if(!appendage) {\n                return;\n        }\n                local obj = appendage.getParent();    \n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//对象管理器的应用 #获取所有控制类对象 #通过map坐标的到ui坐标\n//得到控制对象\n//对象类\nlocal objectManager = obj.getObjectManager();//得到对象管理器\nlocal objectNumber = objectManager.getCollisionObjectNumber();//总数\nfor (local i = 0; i &lt; objectNumber; i++)\n{\n local object = objectManager.getCollisionObject(i);//得到控制类对象\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//遍历对象，判断 是敌人 没死亡 可攻击到 在距离内\n            local xPos = obj.getXPos();//x\n            local yPos = obj.getYPos();//y\n            local zPos = obj.getZPos();//z\n            local distance = obj.getVar().get_vector(2);//距離\n            local objectManager = obj.getObjectManager();//得到對象管理器\n            for (local i = 0; i &lt; objectManager.getCollisionObjectNumber(); i++)\n            {\n                local object = objectManager.getCollisionObject(i);//得到控制類對象\n                if (object\n                    &amp;&amp; object.isObjectType(OBJECTTYPE_ACTIVE)\n                    &amp;&amp; obj.isEnemy(object)\n                    &amp;&amp; object.isInDamagableState(obj)\n                    &amp;&amp; sq_GetDistance(xPos, yPos, object.getXPos(), object.getYPos(), true) &lt;= distance\n                    &amp;&amp; sq_Abs(object.getZPos() - zPos) &lt;= 300)\n                {\n                    local activeObj = sq_GetCNRDObjectToActiveObject(object);//活動類\n                    //沒死亡\n                    if (!activeObj.isDead())\n                    {\n                        sq_sendSetActiveStatusPacket(activeObj, obj, ACTIVESTATUS_STUN, stunProb.tofloat(), stunLevel, false, stunTime);//發送眩暈\n                    }\n                }\n            }\n\n\n_________________________________________________________________________________________________________________________________________________________\n\n//遍历对象 abs绝对值判断长方形距离\n        local direction = obj.getDirection();//得到方向\n        local xPos = sq_GetDistancePos(obj.getXPos(), direction, 300);//得到方向的pos\n        local yPos = obj.getYPos();//y\n        local zPos = obj.getZPos();//z\n            local distanceX = 300;//X距離\n            local distanceY = 90;//Y距離\n            local distanceZ = 50;//Z距離\n            local objectManager = obj.getObjectManager();//得到對象管理器\n            for(local i = 0; i &lt; objectManager.getCollisionObjectNumber(); i++)\n            {\n                local object = objectManager.getCollisionObject(i);//得到控制類對象\n                if(object\n                   &amp;&amp; object.isObjectType(OBJECTTYPE_ACTIVE)\n                   &amp;&amp; obj.isEnemy(object)\n                   &amp;&amp; object.isInDamagableState(obj)\n                   &amp;&amp; sq_Abs(object.getXPos() - xPos) &lt;= distanceX\n                   &amp;&amp; sq_Abs(object.getYPos() - yPos) &lt;= distanceY\n                   &amp;&amp; sq_Abs(object.getZPos() - zPos) &lt;= distanceZ)\n                {\n                    local activeObj = sq_GetCNRDObjectToActiveObject(object);//活動類\n                    //沒死亡\n                    if(!activeObj.isDead())\n                    {\n                        sq_sendSetActiveStatusPacket(activeObj, obj, ACTIVESTATUS_STUN, stunProb.tofloat(), stunLevel, false, stunTime);//發送眩暈\n                    }\n                }\n            }\n\n\n_________________________________________________________________________________________________________________________________________________________\n\nOBJECTTYPE_OBJECT &lt;- 0   //  顶层对象\nOBJECTTYPE_COLLISION &lt;- 1   //  冲突对象；（OBJECTTYPE_OBJECT的下层）\nOBJECTTYPE_ACTIVE &lt;- 17   //  能动的对象 (OBJECTTYPE_COLLISION 的下层)\nOBJECTTYPE_CHARACTER &lt;- 273   //  角色对象 (OBJECTTYPE_ACTIVE 的下层)\nOBJECTTYPE_MONSTER &lt;- 529   //  怪物对象 (OBJECTTYPE_ACTIVE 的下层)\nOBJECTTYPE_RIDABLEOBJECT &lt;- 4625   //  可以骑对象 (OBJECTTYPE_MONSTER 的下层)\nOBJECTTYPE_PASSIVE &lt;- 33   //  特效对象 (OBJECTTYPE_COLLISION 的下层)\nOBJECTTYPE_ITEM &lt;- 289   //  道具对象 (OBJECTTYPE_PASSIVE 的下层)\nOBJECTTYPE_TRAP &lt;- 545   //  트랩 오브젝트 (OBJECTTYPE_PASSIVE 하위)\nOBJECTTYPE_BREAKABLE &lt;- 1057   //  파괴 가능한 오브젝트(보물상자 겸함) (OBJECTTYPE_PASSIVE 하위)\nOBJECTTYPE_PET &lt;- 65   //  신수 (OBJCTTYPE_COLLISION 하위)\nOBJECTTYPE_CREATURE &lt;- 129   //  크리쳐 (OBJCTTYPE_COLLISION 하위)\nOBJECTTYPE_DRAWONLY &lt;- 2   //  그리기 전용 오브젝트 (OBJECTTYPE_OBJECT 하위)\nOBJECTTYPE_VIRTUALCHARACTER &lt;- 18   //  대기실에서 쓰는 가상 캐릭터 (OBJECTTYPE_DRAWONLY 하위)\nOBJECTTYPE_NPC &lt;- 34   //  대기실의 NPC (OBJECTTYPE_DRAWONLY 하위)\nOBJECTTYPE_DONKEY &lt;- 66   //  대기실의 개인상점 (OBJECTTYPE_DRAWONLY 하위)\nOBJECTTYPE_VIRTUALCREATURE &lt;- 130   //  대기실에서 쓰는 가상 크리쳐(OBJECTTYPE_DRAWONLY 하위)\nOBJECTTYPE_DISJOINTSHOP &lt;- 258   //  대기실의 해체가 해체 상점(OBJECTTYPE_DRAWONLY 하위)\nOBJECTTYPE_VIRTUALMONSTER &lt;- 514   //  대기실에서 쓰는 가상 몬스터 (OBJECTTYPE_DRAWONLEY 하위)\nOBJECTTYPE_NONE_DELETE &lt;- 1026   //  오브젝트 삭제 시 삭제되지 않는 오브젝트 (OBJECTTYPE_DRAWONLEY 하위) \nOBJECTTYPE_DEFINE_END &lt;- 61440\n\n_________________________________________________________________________________________________________________________________________________________\n\n//通过ui坐标得到map坐标  通过map坐标得到ui坐标\n\nlocal objectManager = obj.getObjectManager();//得到对象管理器\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到map坐标\nlocal xPos = objectManager.getFieldXPos(IMouse.GetXPos(), ENUM_DRAWLAYER_NORMAL);\nlocal yPos = objectManager.getFieldYPos(IMouse.GetYPos(), 0, ENUM_DRAWLAYER_NORMAL);\nlocal zPos = objectManager.getFieldZPos(IMouse.GetYPos(),目标y坐标, ENUM_DRAWLAYER_NORMAL);\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到ui坐标\nlocal uiXPos = mapXPos - (objectManager.getFieldXPos(mapXPos, ENUM_DRAWLAYER_NORMAL) - mapXPos);\nlocal uiYPos = mapYPos - (objectManager.getFieldYPos(mapYPos, 0, ENUM_DRAWLAYER_NORMAL) - mapYPos);\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到地上掉落的物品对象\nlocal objectManager = obj.getObjectManager();//得到对象管理器\nlocal itemObj = objMgr.getMeetItemObject(IMouse.GetXPos(), IMouse.GetYPos());\n\n_________________________________________________________________________________________________________________________________________________________\n\n//我的特效对象 特效总数的应用 #得到我的特效总数 #得到我的特效\nobj.getMyPassiveObjectCount(24233);//得到特效总数 对象类\nlocal magicBall = obj.getMyPassiveObject(24233,i);//得到我的特效对象\nsq_GetPassiveObjectByState(obj, 24250, BrokenArrow_state_1);//通过状态得到特效\n\nlocal passiveobj_cl = obj.sq_GetPassiveObject(24241);\nlocal pole_passive_obj = sq_GetPassiveObject(obj, 24248);\n\n_________________________________________________________________________________________________________________________________________________________\n\nsq_SendDestroyPacketPassiveObject(magicBall);//破坏特效\n\n_________________________________________________________________________________________________________________________________________________________\n\n//循环获得\nlocal count = obj.getMyPassiveObjectCount(24233);//得到特效总数\nfor(local i = 0; i &lt; count; i++)\n{\n        local magicBall = obj.getMyPassiveObject(24233, i);//得到我的特效对象\n        if(!magicBall)return;\n}\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到 对象ID、组 ，得到对象\nlocal id = sq_GetObjectId(pTargetChr);//得到ID\nlocal object = sq_GetObjectByObjectId(obj, id);//得到对象\n\nlocal group = sq_GetGroup(targetObj);//组\nlocal uniqueId = sq_GetUniqueId(targetObj);//唯一ID\nlocal targetObj = sq_GetObject(obj, group, uniqueId);//得到对象\n\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到对象的重量 高度 宽度\nlocal Weight = sq_GetObjectWeight(obj);//重量\nlocal height = sq_GetObjectHeight(pActiveTarget);//宽度\nlocal width = sq_GetWidthObject(object);//当前宽度\nlocal height = sq_GetHeightObject(object);//当前高度\n\n_________________________________________________________________________________________________________________________________________________________\n\n//得到父 源对象 #特效 #ap\nlocal parentObj = appendage.getParent();//得到父对象\nlocal sourceObj = appendage.getSource();//得到源对象\nlocal attacker = appendage.sq_GetSourceChrTarget();//得到源对象的角色目标\nlocal chr = obj.getTopCharacter();//特效类对象 得到父角色对象\n\n_________________________________________________________________________________________________________________________________________________________\n\n//转换对象类 #转换为别的类\nlocal activeObj = sq_GetCNRDObjectToActiveObject(object);//转为活动类\nlocal sqrChr = sq_GetCNRDObjectToSQRCharacter(parentObj);//转为角色类\nlocal onlyAiChr = sq_GetCNRDObjectToAICharacter(grabChr);//转为apc类\nlocal colObj = sq_GetCNRDObjectToCollisionObject(damager);//转为控制类\nlocal pflashScreen = sq_GetCNRDObjectToFlashScreen(flashScreenObj);//转为闪屏类\nlocal Monster = sq_GetCNRDObjectToMonster(object);//转为怪物类\n\n\n_________________________________________________________________________________________________________________________________________________________\n\n//对象“身上”的数组信息\n//静态var 不会因为死亡 而重置\nIRDSQRCharacter.getStaticVar();\nobj.getStaticVar();\n\n_________________________________________________________________________________________________________________________________________________________\n\n//特别注意，这里的设置，全部都用的一个数组。\n//如果setint 0 设置后你还要再设置别的那么就只能 setBool 1\n//如果想都从0开始不冲突 那么就使用别的数组obj.getVar();或者obj.getVar(\"别的\");\n//int值\nobj.getVar().setInt(0,false);//设置\nobj.getVar().getInt(0);//得到\n//bool值\nobj.getVar().setBool(0,false);//设置\nobj.getVar().getBool(0);//得到\n//浮点数\nobj.getVar().setFloat(0,0.001);//设置\nobj.getVar().getFloat(0);//得到\n//ap\nobj.getVar().setAppendage(0,appendage);\nlocal appendage = obj.getVar().getAppendage(0);\n//对象\nobj.getVar().setObject(0,object);\nlocal object = obj.getVar().getObject(0);\n\n//普通值\nobj.getVar().clear_vector();//清除\nobj.getVar().size_vector();//得到总数\nobj.getVar().push_vector(activeObj);//加入\nobj.getVar().get_vector(0);//得到第几个\nobj.getVar().set_vector(0, cnt);//改变第几个\n\n//时钟\nobj.getVar().clear_timer_vector();\nobj.getVar().push_timer_vector();\nlocal t = obj.getVar().get_timer_vector(0);\nt.setParameter(20, -1);//参数1：检查间隔 参数2：限制次数\nt.resetInstant(0);//重置 参数未知\nt.setEventOnStart(true);//为true 一开始就可以触发\nt.isEnd();//判断次数是否用完\nt.isOnEvent(currentT) == true//判断时间是否到达\nt.getEventTerm();//得到设置时的间隔\nt.getEventMaxCount();//得到设置时的最大次数\nt.setEventTerm(200);//设置间隔\nt.setEventMaxCount(5);//设置最大次数\n\n//计时器\nobj.getVar().clear_ct_vector();//清除\nobj.getVar().push_ct_vector();//加入\nlocal timer = obj.getVar().get_ct_vector(0);//得到\ntimer.Reset();//初始化\ntimer.Start(10000,0);//计时开始\nlocal currentT = timer.Get();//得到时间\n\n//以下是放入任意对象\nobj.getVar().clear_obj_vector();//清除\nobj.getVar().get_obj_vector_size();//得到总数\nobj.getVar().push_obj_vector(activeObj);//加入\nobj.getVar().get_obj_vector(0);//得到第几个\nobj.getVar().set_obj_vector(0, cnt);//改变第几个\nobj.getVar().remove_obj_vector(ringObj);//删除\nobj.getVar().is_obj_vector(damager);//是否在其中\nobj.getVar().get_obj_vector_index(damager);//得到对象当中的ID\n\n//以下是放入ani对象\nobj.getVar().clear_ani_vector();//清除\nobj.getVar().push_ani_vector(activeObj);//加入\nobj.getVar().get_ani_vector(0);//得到第几个\nobj.getVar().set_ani_vector(0, cnt);//改变第几个\n\n//给对象发送状态包  并且  接收传递过来的内容\n\n//发送状态包\n\n//转换对象类\nlocal activeObj = sq_GetCNRDObjectToActiveObject(object);//转为活动类\nlocal sqrChr = sq_GetCNRDObjectToSQRCharacter(parentObj);//转为角色类\nlocal colObj = sq_GetCNRDObjectToCollisionObject(damager);//转为控制类\n\n//这里是发送状态时  给状态定义的类型\nSTATE_PRIORITY_AUTO &lt;- 0 //根据时间和条件自动完成的一切(攻击结束，发射-&gt;战场等等) 特效一般用这个\nSTATE_PRIORITY_USER &lt;- 1 //根据用户的commund发布的内容(技能，攻击等)  一般是使用技能的时候\nSTATE_PRIORITY_HALF_FORCE &lt; 2 / 3 /想要离开，但都比强制要低。(翻过来等)\nSTATE_PRIORITY_FORCE &lt; 3 //被迫去做的事情。(坠落，伤害，死亡，拦截等)  一般给敌人发送控制状态时\nSTATE_PRIORITY_IGNORE_FORCE &lt; 4 //强制变更无视的东西。(用手术刀抓住对方等)   一般是抓取敌人的时候\n\n//下面是发送状态时 还传递数值过去\nobj.sq_IntVectClear();\nobj.sq_IntVectPush(SUB_STATE_BLUEDRAGONWILL_0);\nobj.sq_AddSetStatePacket(STATE_BLUEDRAGONWILL, STATE_PRIORITY_USER, true);//角色类对象 发送状态\n//不传值的话就这样写  更改一下最后的参数为false就行了\nobj.sq_AddSetStatePacket(STATE_BLUEDRAGONWILL, STATE_PRIORITY_USER, false);//角色类对象 发送状态\n\n//如果是复仇者 那么就要这么写  就区分一下大小写的a\nobj.sq_addSetStatePacket(STATE_BLUEDRAGONWILL, STATE_PRIORITY_USER, false);//角色类对象 发送状态\n\n//如果是特效nut中写的话就用这个\nlocal pIntVec = sq_GetGlobalIntVector();//得到包\nsq_IntVectorClear(pIntVec);//清除\nsq_IntVectorPush(pIntVec, x);//加入\nobj.addSetStatePacket(PASSIVEOBJ_SUB_STATE_0, pIntVec, STATE_PRIORITY_AUTO, false, \"\");//控制类对象  发送状态\n\nobj.addSetStatePacket(PASSIVEOBJ_SUB_STATE_0, sq_GetGlobalIntVector(), STATE_PRIORITY_AUTO, false, \"\");//控制类对象  发送状态\n\n//当然也可以 用下面的方法\nobj.sendStateOnlyPacket(PASSIVEOBJ_SUB_STATE_0);//控制类对象 发送状态\nobj.sendStatePacket(PASSIVEOBJ_SUB_STATE_0, 1);//控制类对象 发送状态并且传递过去了一个值\n\n//最后可以刷新一下发送的状态包\nobj.flushSetStatePacket();//刷新发送的状态包\n\n\n//下面的是不常用的 区分活动类对象  或者  控制类对象\n    sq_IntVectorClear(sq_GetGlobalIntVector());\n    sq_IntVectorPush(sq_GetGlobalIntVector(),1);\n    sq_AddSetStatePacketActiveObject(sourceObj,8, sq_GetGlobalIntVector(), STATE_PRIORITY_USER);//活动类对象发送状态\n\n    sq_IntVectorClear(sq_GetGlobalIntVector());\n    sq_IntVectorPush(sq_GetGlobalIntVector(),2);\n    sq_AddSetStatePacketCollisionObject(sourceObj, 8, sq_GetGlobalIntVector(), STATE_PRIORITY_USER, true);//控制类对象发送状态\n\n//这里就开始接收 传递过来的数值\n\n//这个是特效或者技能效果包会用到这个\nlocal x = sq_GetVectorData(datas, 0);\n\n//这个是角色发送的状态 接收的数据\nlocal SubState = obj.sq_GetVectorData(datas, 0);//得到傳過來的第0個值\n\n//发送第13状态的传值介绍\n# STATE_THROW\n[0]   Throw State (0:모으기, 1:던지기, 2:개인시전)\n* Throw State 0 *\n[1]   던지는 타입 (ENUM_THROW_TYPE)\n[2]   던지는 대상의 인덱스 (스킬 인덱스 or 아이템 인덱스)\n[3]   모으는 시간\n[4]   발사 시간\n[5]   던지기 애니메이션 타입 (0 or 1)\n[6]   모으기 속도 타입\n[7]   발사 속도 타입\n[8]   모으기 속도 (안넣으면 SPEED_VALUE_DEFAULT)\n[9]   발사 속도 (안넣으면 SPEED_VALUE_DEFAULT)\n[10]    개인시전 범위 (안넣거나 -1이면 개인시전 안함)\n* Throw State 1 *\n// Throw State 2에서 넘어왔을 경우에만\n[1]    개인 시전시 대상 Object Id\n* Throw State 2 *\nobj.sq_IntVectClear();                \nobj.sq_IntVectPush(0);        // throwState\nobj.sq_IntVectPush(0);        // throwType\nobj.sq_IntVectPush(SKILL_ELEMENTAL_CHANGE);    // throwIndex\nobj.sq_IntVectPush(500);    // throwChargeTime\nobj.sq_IntVectPush(500);    // throwShootTime\nobj.sq_IntVectPush(0);        // throwAnimationIndex\nobj.sq_IntVectPush(4);        // chargeSpeedType\nobj.sq_IntVectPush(4);        // throwShootSpeedType\nobj.sq_IntVectPush(1000);    // chargeSpeedValue\nobj.sq_IntVectPush(1000);    // throwShootSpeedValue\nobj.sq_IntVectPush(-1);        // personalCastRange\nobj.sq_AddSetStatePacket(STATE_THROW, STATE_PRIORITY_USER, true);\n\n//得到当前状态   得到  设置 技能使用状态\n\nlocal SubState = obj.getSkillSubState();//得到技能使用状态\nobj.setSkillSubState(SUB_STATE_BLOODRIVEN_1);//设置技能使用状态\n\nlocal state = obj.sq_GetState();//角色类 得到状态\nlocal state = obj.getSendState();//得到发送的状态\n\nlocal state = obj.getState();//对象类 得到状态\n\n                STATE_STAND &lt;- 0           //  站立，移动\n                STATE_SIT &lt;- 1           //  倒地前\n                STATE_SIT_FOREVER &lt;- 2           //  倒地\n                STATE_DAMAGE &lt;- 3           //  被攻击\n                STATE_DOWN &lt;- 4           //  浮空 \n                STATE_DIE &lt;- 5           //  死亡\n                STATE_JUMP &lt;- 6           //  跳跃\n                STATE_JUMP_ATTACK &lt;- 7           //  跳跃攻击\n                STATE_ATTACK &lt;- 8           //  攻击\n                STATE_HOLD &lt;- 9           //  被控制\n                STATE_SUMMONSTART &lt;- 10           //  召唤开始\n                STATE_SUMMONEND &lt;- 11           //  召唤结束\n                STATE_UNSUMMON &lt;- 12           //  已经被召唤过消失\n                STATE_THROW &lt;- 13           //  投掷\n                STATE_DASH &lt;- 14           //  前冲\n                STATE_DASH_ATTACK &lt;- 15           //  前冲攻击\n                STATE_GET_ITEM &lt;- 16           //  得到道具\n                STATE_BUFF &lt;- 17           //  buff\n\n\n\n                                                                      STATE_QUICK_STANDING &lt;- 18           //  快速起身                            \n                STATE_CROUCH &lt;- 19           //  蹲下\n                STATE_CROUCH_ATTACK &lt;- 20           //  蹲下攻击\n                STATE_LOW_KICK &lt;- 21           //  로킥, 본 크러셔, 사로킥\n                STATE_TRY_GRAB &lt;- 22           //  잡기 시도\n                STATE_SUPLEX &lt;- 23           //  수플렉스\n                STATE_JUMP_SUPLEX &lt;- 24           //  스파이어\n                STATE_JUMP_SUPLEX_LARIAT &lt;- 25           //  스파이어 회전 추가타\n                STATE_MOUNT_TRY &lt;- 26           //  마운트 시도\n                STATE_MOUNT &lt;- 27           //  마운트\n                STATE_STOMP &lt;- 28           //  밟기\n                STATE_CLOSE_PUNCH &lt;- 29           //  원인치 펀치\n                STATE_LIFT_UPPER &lt;- 30           //  무즈 어퍼\n                STATE_GRAB_EXPLOSION &lt;- 31           //  일발화약성\n                STATE_VIRTUAL_ATTACK &lt;- 32           //  일반 공격 -&gt; 해머킥 등을 위한 가상 STATE\n                STATE_SHOULDER_TACKLE &lt;- 33           //  숄더 태클\n                STATE_WHIRL_WIND_KICK &lt;- 34           //  선풍각\n                STATE_BLOCK_BUSTER &lt;- 35           //  블록 버스터\n                STATE_TRY_LEG_SUPLEX &lt;- 36           //  에어슈타이너 시도\n                STATE_LEG_SUPLEX &lt;- 37           //  에어슈타이너 실행\n                STATE_LIGHTNING_DANCE &lt;- 38           //  라이트닝 댄스\n                STATE_THROW_WEB &lt;- 39           //  천라지망\n                STATE_HIDDEN_STING &lt;- 40           //  바늘 장전(히든스팅)\n                STATE_VENOM_MINE &lt;- 41           //  베놈마인\n                STATE_JUNK_SPIN &lt;- 42           //  정크스핀\n                STATE_SHOULDER_CHARGE &lt;- 43           //  철산고\n                STATE_SINGLE_KICK &lt;- 44           //  해머킥\n                STATE_NEN_FLOWER &lt;- 45           //  넨화\n                STATE_THROW_ENEMY &lt;- 46           //  로플링\n                STATE_DASH_PUNCH &lt;- 47           //  정권 찌르기\n                STATE_PUNCH_AFTER_RETURN &lt;- 48           //  타격후 뒤로돌리기\n                STATE_RANDOM_KICK &lt;- 49           //  백열각 난타\n                STATE_RISING_UPPER &lt;- 50           //  승룡권\n                STATE_DASH_AFTER_DASH &lt;- 51           //  호신연격\n                STATE_EARTH_BREAK &lt;- 52           //  금강쇄\n                STATE_HOLD_UP &lt;- 53           //  홀드업\n                STATE_WILD_CANNON_SPIKE &lt;- 54           //  와일드 캐논 스파이크\n                STATE_SUPLEX_CYCLONE &lt;- 55           //  수플렉스 사이클론\n                STATE_LIGHTNING_DRAGON &lt;- 56           //  광충노도\n                STATE_STRONGEST_LOW_KICK &lt;- 57           //  사상 최강의 로킥\n                STATE_GROUND_KICK &lt;- 58           //  그라운드킥\n                STATE_FAST_DASH &lt;- 59           //  순보\n                STATE_DESTROY_EARTH_SKY_DROP &lt;- 60           //  스트리트 파이터 각성기 - 천붕지괴\n                STATE_TYPHOON &lt;- 61           //  그래플러 각성기\n                STATE_FLAME_LEGS &lt;- 62           //  스트라이커 각성기 - 화염의각\n                STATE_THROW_SAND &lt;- 63           //  헬터스?터\n                STATE_ENCHANT_POISON &lt;- 64           //  독장전\n                STATE_SPIRAL_NEN_SHOOT &lt;- 65           //  나선의 넨 : 출\n                STATE_NEN_SPEAR_EX &lt;- 66           //  넨 스피어(특성) proc에서 플래그1에 몸 오버레이,화면 플래쉬    플래그2 에 꽂히는 어펜디지 소환 \n                STATE_HURRICANE_SPEAR &lt;- 67           //  허리케인 스피어 (특성)\n                STATE_CRASH_ROPE &lt;- 68           //  광폭혈사 (특성)\n                STATE_CHARGE_SPEAR_EX &lt;- 69           //  차지 스피어(특성)\n                STATE_SPIRAL_COLUMN_EX &lt;- 70           //  나선환(특성)\n                STATE_GLUEY_FRUIT_EX &lt;- 71           //  끈적끈적 열매(특성)\n                STATE_CHAIN_KICK_EX &lt;- 72           //  연환퇴 (특성)\n                STATE_108_STAIRS_EX &lt;- 73           //  108계단 (특성)\n                STATE_INHERIT_START &lt;- 74 \n                STATE_MAX &lt;- 75\n\n\n//判断是否是我控制的对象\nlocal isMyControl = obj.isMyControlObject();//是否是我控制的角色\nsq_IsMyControlObject(obj);//任意对象\nobj.sq_IsMyControlObject();//角色类\n\n//时钟事件 函数 #利用onTimeEvent事件来指向延时触发的代码\n//设置时钟事件\n//参数1：时钟id\n//参数2：延时时间\n//参数3：最大次数\n//参数4：false一开始不运行 true一开始就运行\nobj.setTimeEvent(0,50,maxCreateCount,false);\n\n//删除时钟事件\nobj.stopTimeEvent(0);\nobj.removeAllTimeEvent();//停止所有时钟事件\n\n//判断时钟是否存在\n\nobj.isExistTimeEvent(0);\n\n//appendage 相关设置 #例如附加ap #增加属性等等\n//得到附加对象 源对象 源角色对象\n//在ap中获得的附加对象是属于 活动类\n//源对象是属于控制类\n\nlocal parentObj = appendage.getParent();//得到附加对象\nlocal sourceObj = appendage.getSource();//得到源对象\nlocal attacker = appendage.sq_GetSourceChrTarget();//得到源对象的角色目标\n\nif(!sourceObj || !parentObj) {\nappendage.setValid(false);\nreturn;\n}    \n\n//也可以\nlocal parentObj = appendage.getAppendageInfo().parent_;//得到附加对象\nlocal sourceObj = appendage.getAppendageInfo().source_;//得到源对象\n//判断ap是否有效\nappendage.isValid();\n//设置 得到有效时间\nlocal appendage = CNSquirrelAppendage.sq_GetAppendage(obj, \"Character/ATMage/MagicShield/ap_MagicShield.nut\");\nif (!appendage)\nreturn;\nappendage.sq_SetValidTime(time);//设置有效时间\nappendage.getAppendageInfo().setValidTime(time);//设置有效时间\n\nlocal validT = appendage.getAppendageInfo().getValidTime();//得到设置的有效时间\n\n//得到ap存在时间\nlocal useTime = appendage.getTimer().Get();\n\n//这里其实是得到的计时器 也可以有这样的操作\ntimer.Reset();//初始化\ntimer.Start(10000,0);//计时开始\nlocal currentT = timer.Get();//得到时间\n\n//关于ap的效果ani的得到跟删除\nappendage.sq_DeleteEffectFront();//删除身前ani\nappendage.sq_DeleteEffectBack();//删除身后ani\nappendage.sq_AddEffectBack(\"Character/Common/Animation/BusterMode/buster_loop_back_normal.ani\");//背后        appendage.sq_AddEffectFront(\"Character/Common/Animation/BusterMode/buster_loop_front_normal.ani\");//身前\n\nlocal ani = appendage.sq_GetFrontAnimation(0);//得到身前的ani\nlocal ani = appendage.sq_GetBackAnimation(0);//得到身后的ani\n//是否是结束\nlocal isEnd = sq_IsEnd(ani);\nif(isEnd)\n{\n        appendage.setValid(false);//销毁ap\n}\n//删除ap的附属物\nappendage.sq_DeleteAppendages();\n\n//得到ap的技能ID 设置技能ID\nlocal skillId = appendage.sq_GetSkillIndex();//得到技能ID\nappendage.sq_SetSkillIndex(100);//设置技能ID\n\n//删除ap\nCNSquirrelAppendage.sq_RemoveAppendage(obj, \"Character/ATMage/MagicShield/ap_MagicShield.nut\");\n\n//判断对象身上是否存在ap\nCNSquirrelAppendage.sq_IsAppendAppendage(obj, \"Character/ATMage/MagicShield/ap_MagicShield.nut\");\n\n//得到对象身上的ap\nlocal dieHardAppendage = CNSquirrelAppendage.sq_GetAppendage(sqrObj, \"Character/ATMage/DieHard/ap_ATMage_DieHard.nut\");\n\n//给对象附加ap\nlocal AddAppendage = CNSquirrelAppendage.sq_AppendAppendage(damager, obj, SKILL_BLOODBOOM, true, \"character/swordman/bloodboom/ap_bloodboom.nut\", true);\n//参数1：附加对象\n//参数2：源对象\n//参数3：技能ID\n//参数4：叠加？ 一般都为false\n//参数5：路径\n//参数6：暂时不知道\n\n//增加属性状态\n//属性类型常量\n\nCHANGE_STATUS_TYPE_PHYSICAL_ATTACK &lt;- 0   //  力量\nCHANGE_STATUS_TYPE_MAGICAL_ATTACK &lt;- 1   //  智力\nCHANGE_STATUS_TYPE_MAGICAL_DEFENSE &lt;- 2   //  精神\nCHANGE_STATUS_TYPE_PHYSICAL_DEFENSE &lt;- 3   //  体力\nCHANGE_STATUS_TYPE_EQUIPMENT_PHYSICAL_ATTACK &lt;- 4   //  装备物理攻击\nCHANGE_STATUS_TYPE_EQUIPMENT_PHYSICAL_DEFENSE &lt;- 5   //  装备物理防御\nCHANGE_STATUS_TYPE_PHYSICAL_ATTACK_BONUS &lt;- 6   //  力量增加率\nCHANGE_STATUS_TYPE_MAGICAL_ATTACK_BONUS &lt;- 7   //  智力增加率\nCHANGE_STATUS_TYPE_JUMP_POWER &lt;- 8   //  跳跃高度\nCHANGE_STATUS_TYPE_JUMP_SPEED_RATE &lt;- 9   //  跳跃速度率\nCHANGE_STATUS_TYPE_ATTACK_SPEED &lt;- 10   //  攻击速度\nCHANGE_STATUS_TYPE_MOVE_SPEED &lt;- 11   //  移动速度\nCHANGE_STATUS_TYPE_CAST_SPEED &lt;- 12   //  释放速度\nCHANGE_STATUS_TYPE_HP_MAX &lt;- 13   //  HP 最大值\nCHANGE_STATUS_TYPE_HP_REGEN_RATE &lt;- 14   //  HP 恢复率\nCHANGE_STATUS_TYPE_PHYSICAL_CRITICAL_HIT_RATE &lt;- 15   //  物理暴击率\nCHANGE_STATUS_TYPE_MAGICAL_CRITICAL_HIT_RATE &lt;- 16   //  魔法暴击率\nCHANGE_STATUS_TYPE_PHYSICAL_BACK_ATTACK_CRITICAL &lt;- 17   //  物理抗暴击\nCHANGE_STATUS_TYPE_MAGICAL_BACK_ATTACK_CRITICAL &lt;- 18   //  魔法抗暴击\nCHANGE_STATUS_TYPE_CRITICAL_TOLERANCE_RATE &lt;- 19   //  暴击抗性率\nCHANGE_STATUS_TYPE_ELEMENT_TOLERANCE_FIRE &lt;- 20   //  火属性抗性\nCHANGE_STATUS_TYPE_ELEMENT_TOLERANCE_WATER &lt;- 21   //  冰属性抗性\nCHANGE_STATUS_TYPE_ELEMENT_TOLERANCE_DARK &lt;- 22   //  暗属性抗性\nCHANGE_STATUS_TYPE_ELEMENT_TOLERANCE_LIGHT &lt;- 23   //  光属性抗性\nCHANGE_STATUS_TYPE_ELEMENT_TOLERANCE_ALL &lt;- 24   //  所有属性抗性\nCHANGE_STATUS_TYPE_ELEMENT_TOLERANCE_ZERO &lt;- 25   //  无属性抗性\nCHANGE_STATUS_TYPE_ACTIVESTATUS_TOLERANCE_ALL &lt;- 26   //  所有异常抗性\nCHANGE_STATUS_TYPE_ACTIVEPROPERTY_STUCK &lt;- 27   // \nCHANGE_STATUS_TYPE_BACK_ATTACK_STUCK_TOLERANCE &lt;- 28   //  \nCHANGE_STATUS_TYPE_MP_REGEN_RATE &lt;- 29   //  MP 恢复率\nCHANGE_STATUS_TYPE_EXTRA_SPEED_RATE &lt;- 30   //  额外速度率\nCHANGE_STATUS_TYPE_EQUIPMENT_MAGICAL_ATTACK &lt;- 31   //  装备魔法攻击\nCHANGE_STATUS_TYPE_EQUIPMENT_MAGICAL_DEFENSE &lt;- 32   //  装备魔法防御\nCHANGE_STATUS_TYPE_STUCK &lt;- 33   //  命中率\nCHANGE_STATUS_TYPE_HIT_RECOVERY &lt;- 34   //  硬直率\nCHANGE_STATUS_TYPE_MELEE_HIT_DELAY &lt;- 35   //  近战被击延时\nCAHNGE_STATUS_TYPE_EQUIPMENT_ALL_STAT &lt;- 36   //  武器所有能力值\nCHANGE_STATUS_TYPE_CUSTOM &lt;- 37 \nCHANGE_STATUS_TYPE_EXP_DOUBLE &lt;- 38   //  双倍经验\nCHANGE_STATUS_TYPE_EVIL_UP &lt;- 39   //  异界抗魔 攻击力，hp，mp提升比率 实际效果是看的数值\nCHANGE_STATUS_TYPE_EVIL_DOWN &lt;- 40   //  异界抗魔 攻击力，hp，mp下降比率 实际效果看的是数值\nCHANGE_STATUS_TYPE_RIGIDITY &lt;- 41   //  僵直度 增加后 增加被敌人攻击时的僵直时间\nCHANGE_STATUS_TYPE_ELEMENT_ATTACK_FIRE &lt;- 42   //  火属性强化\nCHANGE_STATUS_TYPE_ELEMENT_ATTACK_WATER &lt;- 43   //  冰属性强化\nCHANGE_STATUS_TYPE_ELEMENT_ATTACK_DARK &lt;- 44   //  暗属性强化\nCHANGE_STATUS_TYPE_ELEMENT_ATTACK_LIGHT &lt;- 45   //  光属性强化\nCHANGE_STATUS_TYPE_ELEMENT_ATTACK_ALL &lt;- 46   //  所有属性强化\nCHANGE_STATUS_TYPE_DISEASE &lt;- 47   //  韓煽\nCHANGE_STATUS_TYPE_MP_MAX &lt;- 48   //  MP最大值\nCHANGE_STATUS_TYPE_COOLTIME_DECLINE &lt;- 49   //  冷却时间减少\nCHANGE_STATUS_TYPE_PHYSICAL_CRITICAL_DAMAGE_RATE &lt;- 50   // 物理暴击伤害率\nCHANGE_STATUS_TYPE_MAGICAL_CRITICAL_DAMAGE_RATE &lt;- 51   //  魔法暴击伤害率\nCHANGE_STATUS_TYPE_BLOODWAR_GROW_ABILITY &lt;- 52   //  綰楝萄 湍瞪(癱曖鱉) 撩濰 \nCHANGE_STATUS_TYPE_ADDITIONAL_PHYSICAL_GENUINE_ATTACK &lt;- 53   //  附加物理绝对伤害 独立伤害\nCHANGE_STATUS_TYPE_ADDITIONAL_MAGICAL_GENUINE_ATTACK &lt;- 54   //  附加魔法绝对伤害 独立伤害\nCHANGE_STATUS_TYPE_SUMMON_SKILL_POWER_BONUS_RATE &lt;- 55   //  召唤技能力量加成率\nCHANGE_STATUS_TYPE_ANTIEVIL &lt;- 56   //  褒薯 葆溘 熱纂 褻薑\nCHANGE_STATUS_TYPE_PHYSICAL_ABSOLUTE_DAMAGE &lt;- 57   //  物理绝对伤害\nCHANGE_STATUS_GHOST_TRAIN_NO_BREATH_TIME &lt;- 58   //  嶸滄翮離 韓衝 衛除 滲唳\nCHANGE_STATUS_CHARACTER_LINK &lt;- 59   //  議葛攪 葭觼\nCHANGE_STATUS_GOLD_INCREASE &lt;- 60 //获得的金币增加\nCHANGE_STATUS_TYPE_MAX &lt;- 61 \n\npiercing power\n//创建一个属性状态\n//参数1：属性类型\n//参数2：false为增加数值 true为增加百分比数值\n//参数3：增加的数值\n//参数4：时间\nlocal ap = sq_CreateChangeStatus(CHANGE_STATUS_TYPE_ELEMENT_TOLERANCE_FIRE, false, 1000.0 , 0);\nif (ap)\n{\n    ap.getAppendageInfo().setValidTime(10000);//设置有效时间\n    ap.sq_Append(obj, obj);//设置属性的父对象\n}\n//附加ap 并且创建可以看到图标的属性\n//增加可以看到图标的属性\nlocal appendage = CNSquirrelAppendage.sq_AppendAppendage(obj, obj, SKILL_SUPPRESSINGFIRE, false, \"character/gunner/suppressingfire/ap_suppressingfire.nut\", false);//附加一个ap\nlocal change_appendage = appendage.sq_getChangeStatus(\"changeStatus\");//ap的当前状态\nif(!change_appendage)\nchange_appendage = appendage.sq_AddChangeStatus(\"changeStatus\",obj, obj, 500000, CHANGE_STATUS_TYPE_PHYSICAL_CRITICAL_HIT_RATE, false, 1000);//增加一个当前状态\n//参数1：名\n//参数2：对象\n//参数3：对象\n//参数4：有效时间\n//参数5：增加的属性类型\n//参数6：false为增加数值 true为增加百分比数值\n//参数7：数值\n\n//附加ap 创建看不到图标的属性\n//增加看不到图标的属性 一般是被动技能会有一个技能图标，再用这个加上就不会有额外的icon出现 也会加属性\nlocal change_appendage = appendage.sq_getChangeStatus(\"ele_atk_water\");//得到当前状态\nif(!change_appendage)\nchange_appendage = appendage.sq_AddChangeStatusAppendageID(obj, obj, 0, CHANGE_STATUS_TYPE_ELEMENT_ATTACK_WATER, false, registValue, APID_COMMON);//增加一个属性\nif(change_appendage)\n{\nchange_appendage.clearParameter();\nchange_appendage.addParameter(CHANGE_STATUS_TYPE_ELEMENT_ATTACK_WATER, false, registValue.tofloat());//在这里加上真实的属性\n}\n//参数1：增加的属性类型\n//参数2：false为增加数值 true为增加百分比数值\n//参数3：数值\n\n//附加的属性设置ID  按照id 删除属性 #也可以删除所有属性\nsq_RemoveChangeStatus(obj, APID_AT_MAGE_ELEMENT_SHIELD);//删除属性\n\nlocal elementalType = obj.getThrowElement();\nlocal upValue = sq_GetIntData(obj, SKILL_ELEMENTAL_SHIELD, 0);\nlocal ap = sq_CreateChangeStatus(CHANGE_STATUS_TYPE_ELEMENT_TOLERANCE_FIRE + elementalType, false, upValue.tofloat() , 0);\nif (ap)\n{\nap.getAppendageInfo().setValidTime(validTime);\nap.sq_Append(obj, obj, APID_AT_MAGE_ELEMENT_SHIELD, 0, null);\n}\n\n//附加ap的append的作用 #参数的介绍\n\n//参数1：被附加ap者 参数2：附加的源对象\nap.sq_Append(obj, obj);//設置屬性的父對象\n\n//参数1：被附加ap者 参数2：附加的源对象 参数3：设置ap的ID 不可重复附加\nap.sq_Append(obj, obj, APID_SKILL_LIGHT_ENCHANT_WEAPON);\n\n//参数1：被附加ap者 参数2：附加的源对象 参数3：设置ap的ID 不可重复附加 参数4：可叠加次数 参数5：不明\nap.sq_Append(object, obj, APID_AT_MAGE_ELEMENT_SHIELD, 1, null);\n\n//参数1：设置的ap  参数2：被附加ap者 参数3：附加的源对象 参数4：是否是buff\nCNSquirrelAppendage.sq_Append(ap, obj, obj, true);\n\n//参数1：设置的ap 参数2：被附加ap者 参数3：附加的源对象  参数4：设置apID 不可重复附加 参数5：是否是buff\nCNSquirrelAppendage.sq_AppendAppendageID(ap, obj, obj, APID_SKILL_LIGHT_ENCHANT_WEAPON, false);\n\n\n//是否是buff 改为false 则可以带过图 改为true 则不能带过图\n\n\n//增加 删除残影效果\nlocal spectrumAppendage = appendage.sq_GetOcularSpectrum(\"ocularSpectrum\");//得到残影\nif(!spectrumAppendage)\n{\n        spectrumAppendage = appendage.sq_AddOcularSpectrum(\"ocularSpectrum\", obj, obj, 100);//增加残影\n}\nsq_SetParameterOcularSpectrum(spectrumAppendage, 800, 100, true, sq_RGBA(20, 80, 200, 255), sq_RGBA(20, 80, 200, 0), 2, 2, 2);//设置残影效果\nspectrumAppendage.endCreateSpectrum();//删除残影\n\n//附加ap时提升目标的hp或者mp上限值\nlocal appendage = CNSquirrelAppendage.sq_AppendAppendage(obj, obj, SKILL_ATFIGHTER_FIREWORKS, false, \"character/atfighter/fireworks/ap_fireworks.nut\", true);//附加ap\n\nlocal hpmaxup_appendage = appendage.sq_getHpMaxUp(\"HpMaxUp\");//得到\nif (!hpmaxup_appendage)//不存在\nhpmaxup_appendage = appendage.sq_AddHpMaxUp(\"HpMaxUp\", obj, obj, 0, 99999, 99999);//增加\n\n//参数1：name名称\n//参数2：被附加对象\n//参数3：附加对象\n//参数4：持续时间 写0则无限时间\n//参数5：增加的hp值\n//参数6：增加的mp值\n\n//数值需要通过运算后得到正确数值\nlocal convert_rate = sq_GetAbilityConvertRate(obj, CONVERT_TABLE_TYPE_HP);//先得到转换率\nlocal dooms_con_hp = dooms_hp.tofloat() * convert_rate.tofloat();//得到正确的数值\n\n//转换常量\nCONVERT_TABLE_TYPE_DAMAGE &lt;- 0   //  等嘐雖\nCONVERT_TABLE_TYPE_DEFENSE &lt;- 1   //  寞橫溘\nCONVERT_TABLE_TYPE_HP &lt;- 2   //  HP MAX\nCONVERT_TABLE_TYPE_PHYSICAL_ATTACK &lt;- 3   //  \nCONVERT_TABLE_TYPE_PHYSICAL_DEFENSE &lt;- 4   //  羹溘\nCONVERT_TABLE_TYPE_MAGICAL_ATTACK &lt;- 5   //  雖棟\nCONVERT_TABLE_TYPE_MAGICAL_DEFENSE &lt;- 6   //  薑褐溘\nCONVERT_TABLE_TYPE_PHYSICAL_ABSOLUTE_DAMAGE &lt;- 7   //  僭葬 瞰渠 等嘐雖\nCONVERT_TABLE_TYPE_PHYSICAL_DAMAGE_REDUCE &lt;- 8   //  僭葬 等嘐雖 爾薑\nCONVERT_TABLE_TYPE_MAGICAL_ABSOLUTE_DAMAGE &lt;- 9   //  葆徹 瞰渠 等嘐雖\nCONVERT_TABLE_TYPE_MAGICAL_DAMAGE_REDUCE &lt;- 10   //  葆徹 等嘐雖 爾薑\nCONVERT_TABLE_TYPE_ACTIVESTATUS_DAMAGE_REDUCE &lt;- 11   //  鼻鷓檜鼻 等嘐雖 爾薑.\nCONVERT_TABLE_TYPE_MP &lt;- 12   //  MP MAX\nCONVERT_TABLE_TYPE_SKILL_POWER &lt;- 13   //  蝶鑒 絮董等嘐雖\nCONVERT_TABLE_TYPE_MAX &lt;- 14 \n\n//附加ap时恢复hp血量\nlocal appendage = CNSquirrelAppendage.sq_AppendAppendage(obj, obj, SKILL_ATFIGHTER_FIREWORKS, false, \"character/atfighter/fireworks/ap_fireworks.nut\", true);//附加ap\nlocal change_appendage = appendage.sq_GetCNChangeHp(\"changehp\");//得到hp\nif (!change_appendage)\n        change_appendage = appendage.sq_AddCNChangeHp(\"changehp\", obj, obj, 0, 50000.0, 5000);//恢复设置\n\n//参数1：name名称 \n//参数2：被附加对象 \n//参数3：附加对象 \n//参数4：0\n//参数5：增加的hp值  浮点数\n//参数6：恢复总时间\n\n//吸附ap #测试效果不好 #使用原版的代码附加ap后会一直改变y坐标 #搞不明白到底有啥用\nlocal appendage = CNSquirrelAppendage.sq_AppendAppendage(parentObj, obj, SKILL_FROZENLAND, false, \"Appendage/Character/ap_common_suck.nut\", false);\nlocal suckVel = 200;\nlocal radiusSize = obj.getVar(\"radius\").get_vector(1);\nlocal range = radiusSize * 2;\nif(appendage)\n{\nappendage.sq_SetValidTime(2000);\nCNSquirrelAppendage.sq_Append(appendage, parentObj, obj);\nlocal auraAppendage = appendage.sq_getAuraMaster(\"frozenAura\");\nif(!auraAppendage)\nauraAppendage = appendage.sq_AddAuraMaster(\"frozenAura\",parentObj, obj, 1200, 18, 5, 0);\nauraAppendage.setAttractionInfo(suckVel, suckVel, range, 100);\n}\n\n//额外附加 延时死亡并控制\n//参数1：附加对象 \n//参数2：源对象 \n//参数3：是否控制 \n//参数4：是否延时死亡 \n//参数5：销毁ap时是否击飞 \n//参数6：击飞距离 \n//参数7：击飞高度\n//参数8：方向\n//参数9：父ap （父ap销毁则控制ap也销毁）\nsq_HoldAndDelayDie(damager, obj, true, true, true, 200, 200, ENUM_DIRECTION_NEUTRAL , masterAppendage);\n\n//额外附加 均匀移动\n//参数1：附加对象\n//参数2：源对象\n//参数3：以此对象坐标为基准\n//参数4：偏移的x坐标\n//参数5：偏移的y坐标\n//参数6：偏移的z坐标\n//参数7：到达目标时间\n//参数8：没测试一般为true\n//参数9：父ap （父ap销毁则控制ap也销毁）\nsq_MoveToAppendageForce(ChrJob, obj, obj, 160, 0, ChrJob.getZPos(), 3000, true, masterAppendage);//强制移动\n\n//也可以改为下面的 则有坐标到达不了就不会再移动\nsq_MoveToAppendage(ChrJob, obj, obj, 160, 0, ChrJob.getZPos(), 3000, true, masterAppendage);//强制移动\n\n\n//额外附加 由快到慢 由慢到快移动\n//参数1：附加对象\n//参数2：源对象\n//参数3：以此对象坐标为基准\n//参数4：偏移的x坐标\n//参数5：偏移的y坐标\n//参数6：偏移的z坐标\n//参数7：到达目标时间\n//参数8：没测试一般为true\n//参数9：父ap （父ap销毁则控制ap也销毁）\n//参数10：true代表由快到慢 false代表由慢到快\nsq_AccelMoveToAppendageForce(aoDamager, obj, obj, x, 0, z - aoDamager.getObjectHeight()/2, liftTime, true, masterAppendage,true);//强制移动\n\n//也可以改为下面的 则有坐标到达不了就不会再移动\nsq_AccelMoveToAppendage(aoDamager, obj, obj, x, 0, z - aoDamager.getObjectHeight()/2, liftTime, true, masterAppendage,true);\n\n//ani以及绘画对象的设置\n//图层 以及 对象常量\n                ENUM_DRAWLAYER_CONTACT &lt;- 0           //  前景 创建后所有的都看不到了\n                ENUM_DRAWLAYER_NORMAL &lt;- 1           //  正常图层\n                ENUM_DRAWLAYER_BOTTOM &lt;- 2           //  底层图层\n                ENUM_DRAWLAYER_CLOSEBACK &lt;- 3           //  map 地板图层\n                ENUM_DRAWLAYER_MIDDLEBACK &lt;- 4           //  map 远景图层 房屋之类的\n                ENUM_DRAWLAYER_DISTANTBACK &lt;- 5           //  map 远景图层 背景\n                ENUM_DRAWLAYER_COVER &lt;- 6           //  顶层图层\n                ENUM_DRAWLAYER_MAX &lt;- 7 \n\n                OBJECTTYPE_OBJECT &lt;- 0           //  顶层对象\n                OBJECTTYPE_COLLISION &lt;- 1           //  冲突对象；（OBJECTTYPE_OBJECT的下层）\n                OBJECTTYPE_ACTIVE &lt;- 17           //  能动的对象 (OBJECTTYPE_COLLISION 的下层)\n                OBJECTTYPE_CHARACTER &lt;- 273       //  角色对象 (OBJECTTYPE_ACTIVE 的下层)\n                OBJECTTYPE_MONSTER &lt;- 529       //  怪物对象 (OBJECTTYPE_ACTIVE 的下层)\n                OBJECTTYPE_RIDABLEOBJECT &lt;- 4625       //  可以骑对象 (OBJECTTYPE_MONSTER 的下层)\n                OBJECTTYPE_PASSIVE &lt;- 33           //  特效对象 (OBJECTTYPE_COLLISION 的下层)\n                OBJECTTYPE_ITEM &lt;- 289           //  道具对象 (OBJECTTYPE_PASSIVE 的下层)\n                OBJECTTYPE_TRAP &lt;- 545           //  트랩 오브젝트 (OBJECTTYPE_PASSIVE 하위)\n                OBJECTTYPE_BREAKABLE &lt;- 1057       //  파괴 가능한 오브젝트(보물상자 겸함) (OBJECTTYPE_PASSIVE 하위)\n                OBJECTTYPE_PET &lt;- 65           //  신수 (OBJCTTYPE_COLLISION 하위)\n                OBJECTTYPE_CREATURE &lt;- 129       //  크리쳐 (OBJCTTYPE_COLLISION 하위)\n                OBJECTTYPE_DRAWONLY &lt;- 2           //  그리기 전용 오브젝트 (OBJECTTYPE_OBJECT 하위)\n                OBJECTTYPE_VIRTUALCHARACTER &lt;- 18       //  대기실에서 쓰는 가상 캐릭터 (OBJECTTYPE_DRAWONLY 하위)\n                OBJECTTYPE_NPC &lt;- 34           //  대기실의 NPC (OBJECTTYPE_DRAWONLY 하위)\n                OBJECTTYPE_DONKEY &lt;- 66           //  대기실의 개인상점 (OBJECTTYPE_DRAWONLY 하위)\n                OBJECTTYPE_VIRTUALCREATURE &lt;- 130       //  대기실에서 쓰는 가상 크리쳐(OBJECTTYPE_DRAWONLY 하위)\n                OBJECTTYPE_DISJOINTSHOP &lt;- 258       //  대기실의 해체가 해체 상점(OBJECTTYPE_DRAWONLY 하위)\n                OBJECTTYPE_VIRTUALMONSTER &lt;- 514       //  대기실에서 쓰는 가상 몬스터 (OBJECTTYPE_DRAWONLEY 하위)\n                OBJECTTYPE_NONE_DELETE &lt;- 1026       //  오브젝트 삭제 시 삭제되지 않는 오브젝트 (OBJECTTYPE_DRAWONLEY 하위) \n                OBJECTTYPE_DEFINE_END &lt;- 61440\n\n\n\n//得到rgb  ALPHA\nlocal rgba = sq_ALPHA(255,255,255,0);//rgba\nlocal rgb = sq_RGB(255,255,255);//rgb\nlocal a = sq_ALPHA(255);//透明度\n\n\n//得到 设置 ani\n\n//得到自定义ani\nobj.sq_getCustomAni(CUSTOM_ANI_AVENGER_ATTACK_4_ROSARY);//复仇者\nsq_GetCustomAni(obj, 57);//按道理是都可以用\nlocal ani = obj.getCustomAnimation(0);//对象类\n//得到当前ani\nlocal ani = sq_GetCurrentAnimation(obj);//角色；特效；绘画对象\nlocal ani = obj.getCurrentAnimation();//角色；特效；绘画对象\nlocal ani = obj.sq_GetCurrentAni();//角色；\n//得到默认ani\nobj.getDefaultAnimation();//对象类 得到默认ani\n//判断是否是默认ani\nobj.isCurrentAnimationDefault();//对象类 判断是否是默认ani\n//设置当前ani\nobj.sq_SetCurrentAnimation(CUSTOM_ANI_CONCENTRATE_EX);//角色\nsetCurrentAnimationFromCutomIndex(obj, 0);//特效\nobj.setCurrentAnimation(ani);//对象类\n\n//设置ani的播放速度   人物的当前所有ani的速度\n\npAni.setSpeedRate(200.0);//速度率\nobj.sq_SetAnimationSpeedRate(obj.sq_GetCurrentAni(),attackSpeedRate.tofloat());//设置ani的速度率\n\n//设置静态速度的信息\n//参数说明：\n//1.速度类型\n//2.速度类型\n//3.速度值\n//4.速度值\n//5.速度加成率\n//6.速度加成率\n//一般为改最后面的两个参数可以调整速度\nobj.sq_SetStaticSpeedInfo(SPEED_TYPE_ATTACK_SPEED, SPEED_TYPE_ATTACK_SPEED, SPEED_VALUE_DEFAULT, SPEED_VALUE_DEFAULT, 1.0, 1.0);\n\n//按比例增加 不吃任何速度，固定增加速度 更改1.5的那个数值 就是增加50%的速度\nobj.sq_SetStaticSpeedInfo(0, 0, 0, (1000*1.5).tointeger(), 0.0, 0.0);//设置固定速度\n\nSPEED_TYPE_CONST                        &lt;- 0    \nSPEED_TYPE_MOVE_SPEED                    &lt;- 1    //移动速度\nSPEED_TYPE_ATTACK_SPEED                    &lt;- 2    //攻击速度\nSPEED_TYPE_EXCEPT_WEAPON_ATTACK_SPEED    &lt;- 3    //除了攻击速度\nSPEED_TYPE_CAST_SPEED                    &lt;- 4    //施放速度\n\n//改变图片大小 攻击框大小\n\nlocal ani = obj.getCurrentAnimation();//得到当前ani\nlocal sizeRate = sizeRate.tofloat() / 100.0;//转换浮点数运算\ncurrentAni.setImageRateFromOriginal(sizeRate, sizeRate);//增加ani 宽度跟高度率\ncurrentAni.setAutoLayerWorkAnimationAddSizeRate(sizeRate);//增加ani als附加 ani大小比例\nsq_SetAttackBoundingBoxSizeRate(currentAni, sizeRate, sizeRate, sizeRate);//攻击框，x y z比率\n//下面不常用\ncurrentAni.applyBoundingBoxRate(explosionSizeRate,0,0);//攻击框\ncurrentAni.setAttackBoundingBoxSizeRate(sizeRate,true);//攻击框\ncurrentAni.setImageRate(1.0, 1.0);//比率\nani.resize(sizeRate);//比率\nani.resizeWithChild(size);//比率\n\n//判断当前自定义etc的ani ID\nobj.isCurrentCutomAniIndex(CUSTOM_ANI_PUSH_OUT_GRAB);\n//活动类对象\n\n//创建ani\nlocal ani = sq_CreateAnimation(\"\",\"\");//创建ani\n参数1： 参数2：都是路径\n\n//根据角色类型，来取决于路径\nobj.sq_CreateCNRDAnimation(\"Effect/Animation/ATElementalRain/Cast/1_under_dodge.ani\")\n\nlocal ani = obj.getVar().GetAnimationMap(\"Disaster1\", \"Character/Priest/Animation/disasterEx/Disaster1.ani\");\n\n//销毁绘画对象\naniobj.setValid(false);//销毁\n//以父图层创建绘画对象 #参数中可以更改x y z坐标\nlocal pooledObj = sq_AddDrawOnlyAniFromParent(obj,\"character/swordman/effect/animation/swordofmind/charging.ani\", 0, 0, 0);\n//创建绘画对象 #设置图层 #可以更改ani结束时是否销毁\nlocal pooledObj = sq_CreateDrawOnlyObject(obj, \"PassiveObject/Character/Mage/Animation/ATDarknessMantle/exp/3_exp_shock_normal_1.ani\", ENUM_DRAWLAYER_NORMAL, true);\n//更高端的创建绘画对象 #手动创建ani #以及设置坐标图层等\nlocal ani = sq_CreateAnimation(\"\",\"\");//创建ani\nlocal pooledObj = sq_CreatePooledObject(ani,true);//创建绘画对象 参数2：应该是ani结束时true 就销毁反之false不销毁\nsq_SetCurrentDirection(pooledObj, obj.getDirection());//设置方向\npooledObj.setCurrentPos(x,y,z);//设置pos\npooledObj = sq_SetEnumDrawLayer(pooledObj, ENUM_DRAWLAYER_BOTTOM);//设置图层\nsq_AddObject(obj, pooledObj, OBJECTTYPE_DRAWONLY, false);//增加对象\n//得到当前ani的时间 得到ani的区间或总延时\nlocal ani = obj.getCurrentAnimation();//角色；特效；绘画对象\n//得到ani当前时间\nlocal currentT = sq_GetCurrentTime(pAni);//ani得到当前时间\n//得到ani延时\nlocal delay = ani.getDelaySum(false);//ani延时总和\nlocal delay = ani.getDelaySum(0, 2);//第几帧到第几帧总和\nlocal delay = ani.getDelayBySpeedRate(1);//按照速度率\nobj.sq_GetDelaySum();//得到当前的ani总延时 角色类对象\nlocal startTime = sq_GetDelaySum(animation);//得到ani总延时\n\n//得到当前帧ID\nsq_GetCurrentFrameIndex(obj);//角色；特效\nsq_GetAnimationFrameIndex(pAni);//ani\nobj.sq_GetCurrentFrameIndex(pAni);//角色\n\n\n//设置当前帧ID\nsq_SetAnimationFrameIndex( backAni, currentAniFrameIndex);\nani.setCurrentFrameWithChildLayer(11);\n\n//设置ani帧的延时时间\nsq_SetFrameDelayTime(animation, 0, castTime);\nani.setFrameDelay(4,maxTime,true);\nani.proc();\n//得到ani的帧总数\nlocal poleAniFrameNumber = sq_GetAniFrameNumber(poleAni, 0);//ani总数\n//判断ani是否结束\nlocal isEnd = sq_IsEnd(ani);//是否结束\n//倒回ani #重新播放\nsq_Rewind(ani);//倒回 重播\nobj.sq_Rewind(animation);//倒回 重播\n设置ani的rgba值 #颜色及透明度\n//ani1.setRGBA(0, 78, 255, 255);\n//设置ani的效果层 #在原图片图层上再增加一个图型样式\nlocal effectType = GRAPHICEFFECT_DODGE;//图形效果类型\nlocal rgb = sq_RGB(0, 90, 255);//rgb颜色值\n\nlocal effectT = 600;\nlocal startT = 200;\nlocal endT = 50;\nlocal targetV = endT;\nlocal al = sq_GetUniformVelocity(startT, targetV, appendage.getTimer().Get(), effectT);\nlocal alpha = sq_ALPHA(al);//获得透明度\n//设置效果层  最后一个参数是 所有层ani是否也更改\npAni.setEffectLayer(true, effectType, true, rgb, alpha, true, false);\n\n\n\n\n                GRAPHICEFFECT_NONE &lt;- 0           //  橈擠\n                GRAPHICEFFECT_DODGE &lt;- 1           //  游雖\n                GRAPHICEFFECT_LINEARDODGE &lt;- 2           //  葬棲橫 游雖\n                GRAPHICEFFECT_DARK &lt;- 3           //  棻觼\n                GRAPHICEFFECT_XOR &lt;- 4           //  XOR\n                GRAPHICEFFECT_MONOCHROME &lt;- 5           //  欽儀\n                GRAPHICEFFECT_SPACE_DISTORT &lt;- 6           //  奢除諼堊\nGRAPHICEFFECT_MAX &lt;- 7 \n\n//以下是我自己实操，巡回更改颜色值\n    local pAni = parentObj.getCurrentAnimation();//得到当前ani\n    if(pAni)\n    {\n        local currentT = appendage.getTimer().Get();//当前时间\n        local fireT = 350;//总时间\n        if(currentT / fireT % 2 == 1)\n        {\n            currentT = fireT - currentT % fireT;//再次计算轮回时间\n        }\n        else\n            currentT = currentT % fireT;//轮回当前时间\n        local al = sq_GetUniformVelocity(10,100, currentT, fireT);//计算透明度\n        local alpha = sq_ALPHA(al);//得到透明度\n        local rgb = sq_RGB(255, 0, 0);//rgb 红色\n        pAni.setEffectLayer(true, GRAPHICEFFECT_LINEARDODGE, true, rgb, alpha, true, false);//设置效果层\n        //得到层ani 范围\n        local size = sq_AniLayerListSize(pAni);\n        for(local i = 0; i &lt; size; i++)\n        {\n            local aniL = sq_getAniLayerListObject(pAni, i);//得到层ani\n            if(aniL)\n            {\n                local effect = aniL.GetCurrentFrame().GetGraphicEffect();//得到ani当前帧的效果\n                if(effect != GRAPHICEFFECT_LINEARDODGE)//不是线性减淡 那么就改变颜色\n                    aniL.setEffectLayer(true, GRAPHICEFFECT_LINEARDODGE, true, rgb, alpha, true, false);\n            }\n        }\n    }\n\n//创建特效 #ani #atk #伤害 #攻击范围 #坐标都可设置 #唯一缺点穿刺无法设置 #攻击到人立马销毁\n//创建只攻击对象 ani跟atk \n参数1：ani路径\n参数2：atk路径\n参数3：false 固伤；true 百分比\n参数4：这里提供的数值 被参数3控制，固伤或百分比\n参数5：攻击框比率\n参数6：偏移x\n参数7：偏移y\n参数8：偏移z\nsq_createAttackObjectWithPath(obj, \"Character/Swordman/Effect/Animation/Bloodboom/finish_bloodboom_finish3.ani\",\"passiveobject/script_sqr_nut_qq506807329/swordman/attackinfo/bloodboomfinish.atk\",true,0,100,200,0,0);\n//改变图层\nsq_ChangeDrawLayer(obj, ENUM_DRAWLAYER_BOTTOM);//改变图层\n//增加状态层ani #切换状态时会自动删除\nobj.sq_AddStateLayerAnimation(1,obj.sq_CreateCNRDAnimation(\"Effect/Animation/ATElementalRain/Cast/1_under_dodge.ani\"), 0, 0);\n//增加 删除 得到层ani #ani的子ani\ncurrentAni.addLayerAnimation(6,sq_CreateAnimation(\"\",\"PassiveObject/Character/Mage/Animation/ATLightningWall/7_el-p1_dodge_1.ani\"),true);//增加层ani\npAni.removeLayerAnimation(backlight_dodge);//删除层ani\nlocal size = sq_AniLayerListSize(pAni);//得到ani层的范围\nlocal pAniL = sq_getAniLayerListObject(pAni, i);//得到层ani\n//附加ap 设置效果层\n//设置效果层;参数4：到达指定颜色需要的时间 参数5：消失的多少时间 参数6：附加多长时间\nsq_EffectLayerAppendage(damager,sq_RGB(0,144,255),150,0,0,240);\nsq_EffectLayerAppendageOnlyBody(obj, sq_RGB(255,255,255), 255, 0, 0, 320);\nsq_SetBodyEffect(obj, obj, true, sq_RGB(255, 255, 255), 0, 80, 0, sq_ALPHA(255));\n//得到als中的ani\nlocal alsSpinNormal = obj.sq_getAutoLayerWorkAnimation(pAni, \"2_sn\");\nlocal aniL = obj.sq_GetAutoLayerWorkAnimation(pAni,\"Dodge\");//得到als层ani\n//创建固定在屏幕中央的ani\nsq_setFullScreenEffect(obj, \"pet/falcon/animation/rest.ani\");//固定在屏幕中央的效果ani\n//删除ani\nsq_DeleteAni(backAni);//删除ani\n//清除攻击框 增加攻击框\n//ani关闭攻击框\nsq_ClearAttackBox(pAni);\n//增加攻击框\nsq_AddAttackBox(pAni,      \n                attackPosX.tointeger() - (attackL / 2), \n                attackPosY.tointeger(), \n                -zAttackL, \n                attackL, attackL, (zAttackL * 2) );\n\n//得到ani当前帧 得到帧的图形效果类型 #例如判断线性减淡等等\nlocal frame = ani.GetCurrentFrame();//得到当前帧\nlocal effect = aniL.GetCurrentFrame().GetGraphicEffect();//得到图形效果\n\n                GRAPHICEFFECT_NONE &lt;- 0           //  橈擠\n                GRAPHICEFFECT_DODGE &lt;- 1           //  游雖\n                GRAPHICEFFECT_LINEARDODGE &lt;- 2           //  葬棲橫 游雖\n                GRAPHICEFFECT_DARK &lt;- 3           //  棻觼\n                GRAPHICEFFECT_XOR &lt;- 4           //  XOR\n                GRAPHICEFFECT_MONOCHROME &lt;- 5           //  欽儀\n                GRAPHICEFFECT_SPACE_DISTORT &lt;- 6           //  奢除諼堊\n                GRAPHICEFFECT_MAX &lt;- 7 \n\n//判断ani的key flag标签  或  清除\nobj.sq_IsKeyFrameFlag(ani, 1);//是否是\nobj.sq_ClearKeyFrameFlag(ani);//清除key\n//判断是否是相同的ani\nsq_IsSameAni(explosionAni,currentAni);//判断是否相同\n//得到我的ani的阴影类型\nsq_GetShadowTypeByAnimation()\n//得到ani img的范围大小\nlocal ani = obj.getCurrentAnimation();\nlocal radiusSize = sq_GetAniRealImageSize(ani, 0);\nlocal boundBox = sq_GetAttackBoundRect(ani);\nlocal bosXSize = sq_GetBoundingBoxXSize(boundBox);\nlocal range = bosXSize;\n//atk以及攻击的设置\n//得到 设置 atk\n//得到自定义攻击信息\nlocal attackInfo = sq_GetCustomAttackInfo(obj, 0);//角色；特效\n//得到当前攻击信息\nlocal attackInfo = sq_GetCurrentAttackInfo(obj);//角色；特效\n//得到默认攻击信息\nlocal attackInfo = sq_GetDefaultAttackInfo(obj);\n//设置当前攻击信息\nobj.sq_SetCurrentAttackInfo(CUSTOM_ATTACK_BLOODRIVENMULTIHIT);//角色\nsq_SetCurrentAttackInfoFromCustomIndex(obj, 0);//特效\nsq_SetCurrentAttackInfo(obj, attackInfo);//角色；特效\n//得到技能\nlocal skill = sq_GetSkill(obj, SKILL_WATER_CANNON);\n//得到技能等级\nlocal skill_level = sq_GetSkillLevel(obj, SKILL_ICEROAD);//技能等级\n//得到静态 动态数据\n//得到动态数据\nlocal validTime = obj.sq_GetLevelData(SKILL_ELEMENTAL_CHAIN, 1, skill_level);//参数1：技能编号 参数2：动态第几个 参数3：技能等级\nsq_GetLevelData(obj,SKILL_METEORSWORD, 0, skill_level);//参数1：对象 参数2：技能编号 参数3：动态第几个 参数4：技能等级\n\n//得到静态数据\nobj.sq_GetIntData(SKILL_WIND_STRIKE, 0);//参数1：技能编号 参数2：静态第几个\nsq_GetIntData(obj, SKILL_DIEHARD, 0);//参数1：对象 参数2：技能编号 参数3：静态第几个\n\n//得到  设置  根据人物状态加成的 固伤，百分比数值\nsq_GetCurrentAttackBonusRate(obj);//得到对象身上的百分比率\n//得到百分比\n//参数1：技能编号 参数2：状态编号 参数3：动态数据第几个 参数4：以多少比率获取\nlocal attackBonusRate = obj.sq_GetBonusRateWithPassive(SKILL_WIND_STRIKE, STATE_WIND_STRIKE, 0, 1.0);\n\n//得到固伤\n//参数1：技能编号 参数2：状态编号 参数3：固伤动态数据第几个 参数4：百分比率动态数据第几个 参数5：以多少比率获取\n//这里参数3 跟参数4  是技能又有固伤也有百分比才这样写，好像是官方设定的一种获取伤害的计算方式\n//如果只有固伤的话 参数4写 -1就行了\nlocal power = obj.sq_GetPowerWithPassive(SKILL_WIND_STRIKE, STATE_WIND_STRIKE, 1, 0, 1.0);\n\n//设置百分比\nobj.sq_SetCurrentAttackBonusRate(power);//角色类\nsq_SetCurrentAttackBonusRate(attackInfo, attackBonusRate);//给攻击信息设置百分比值\n\n//设置固伤\nobj.sq_SetCurrentAttackPower(power);//角色类 \nsq_SetCurrentAttackPower(attackInfo, attackPower);//给攻击信息设置固伤值\n\n//给攻击信息设置一些属性 #例如属性类型 #是否吃物理魔法攻击之类的\nattackInfo.setElement(ENUM_ELEMENT_NONE);//设置攻击属性\n                ENUM_ELEMENT_FIRE    &lt;- 0    /// 火属性\n                ENUM_ELEMENT_WATER    &lt;- 1    /// 冰属性\n                ENUM_ELEMENT_DARK    &lt;- 2    /// 暗属性\n                ENUM_ELEMENT_LIGHT    &lt;- 3    /// 光属性\n                ENUM_ELEMENT_NONE    &lt;- 4    /// 无属性\n                ENUM_ELEMENT_MAX    &lt;- 4    /// == ENUM_ELEMENT_NONE\n\nattackInfo.isValidElement(ENUM_ELEMENT_FIRE);//判断是否是该属性\n\nsq_SetCurrentAttackeHitStunTime(sq_GetCurrentAttackInfo(obj), 0);//设置攻击击晕时间\n\nsq_SetAttackInfoForceHitStunTime(atk, stunTime);//强制击晕时间\n\nlocal rateDamager = sq_GetAttackInfoHitDelayRateDamager(attackerInfo);//得到击中僵直率\nsq_SetAttackInfoHitDelayRateDamager(attackerInfo, 0.0); //设置击中僵直率\n\n//设置攻击反应\nsq_SetCurrentAttackeDamageAct(attackInfo, 1);\n        //DAMAGEACT_NONE = 0,    无\n        //DAMAGEACT_DAMAGE = 1,    伤害\n        //DAMAGEACT_DOWN = 2,    倒地\n\n//得到攻击类型  设置攻击类型\nsq_ChangeAttackTypeToOpposite(attack_info);//设置相反的攻击类型\nlocal eType = sq_GetAttackType(attack_info);//得到攻击类型\nattackInfo.setAttackType(ATTACKTYPE_MAGICAL); //设置攻击类型\nsq_setAttackInfoType(obj,ATTACKTYPE_MAGICAL);//设置攻击类型\n                ATTACKTYPE_PHYSICAL &lt;- 0           //物理\n                ATTACKTYPE_MAGICAL &lt;- 1           //魔法\n                ATTACKTYPE_ABSOLUTE &lt;- 2           //无视防御\n\n\nsq_SetAddWeaponDamage(attackInfo, true);//吃物理魔法攻击力 百分比伤害必加  参数2改为false代表不吃\n\nsq_SetCurrentAttacknBackForce(pAttack, 800);//推开距离\nsq_SetCurrentAttacknUpForce(pAttack, 300);//打击高度\n\nsq_SetCurrentAttackDirection(pAttack, ATTACK_DIRECTION_UP);//攻击方向\nATTACK_DIRECTION_UP &lt;- 0         \nATTACK_DIRECTION_HORIZON &lt;- 1     \nATTACK_DIRECTION_DOWN &lt;- 2         \nATTACK_DIRECTION_MAX &lt;- 3 \n\n//得到atk类的属性 为bool值  忽略延时死亡无敌状态 例如男魔法的复活被动\nattackInfo.isIgnoreDieHard_\n\n//atk攻击信息 设置异常状态攻击\n//設置攻擊異常狀態；攻击信息，，异常类型，概率，等级，时间，伤害\nsq_SetChangeStatusIntoAttackInfo(attackInfo, 0, ACTIVESTATUS_BLEEDING,bleedingrate,bleedinglevel,bleedingtime,bleedingdamage);\n\n\n\n                ACTIVESTATUS_SLOW &lt;- 0           //  减速\n                ACTIVESTATUS_FREEZE &lt;- 1           //  冰冻\n                ACTIVESTATUS_POISON &lt;- 2           //  中毒\n                ACTIVESTATUS_STUN &lt;- 3           //  眩晕\n                ACTIVESTATUS_CURSE &lt;- 4           //  诅咒\n                ACTIVESTATUS_BLIND &lt;- 5           //  失明\n                ACTIVESTATUS_LIGHTNING &lt;- 6           //  感电\n                ACTIVESTATUS_STONE &lt;- 7           //  石化\n                ACTIVESTATUS_SLEEP &lt;- 8           //  睡眠\n                ACTIVESTATUS_BURN &lt;- 9           //  燃烧\n                ACTIVESTATUS_WEAPON_BREAK &lt;- 10           //  武器破甲\n                ACTIVESTATUS_BLEEDING &lt;- 11           //  出血\n                ACTIVESTATUS_HASTE &lt;- 12           //  加速\n                ACTIVESTATUS_BLESS &lt;- 13           //  祝福\n                ACTIVESTATUS_ELEMENT &lt;- 14           //  엘레먼트\n                ACTIVESTATUS_CONFUSE &lt;- 15           //  混乱\n                ACTIVESTATUS_HOLD &lt;- 16           //  束缚\n                ACTIVESTATUS_ARMOR_BREAK &lt;- 17           //  护甲破甲\n                ACTIVESTATUS_MAX &lt;- 18\n\n\n//直接发送异常状态\n//直接发送异常状态包；被附加对象，我自己，异常类型，概率(浮点数)，等级，强制false，时间\nsq_sendSetActiveStatusPacket(obj, parentObj, ACTIVESTATUS_BLIND, dark_prob.tofloat(), dark_power.tointeger(), false, dark_time.tointeger());\n\n\n\n                ACTIVESTATUS_SLOW &lt;- 0           //  减速\n                ACTIVESTATUS_FREEZE &lt;- 1           //  冰冻\n                ACTIVESTATUS_POISON &lt;- 2           //  中毒\n                ACTIVESTATUS_STUN &lt;- 3           //  眩晕\n                ACTIVESTATUS_CURSE &lt;- 4           //  诅咒\n                ACTIVESTATUS_BLIND &lt;- 5           //  失明\n                ACTIVESTATUS_LIGHTNING &lt;- 6           //  感电\n                ACTIVESTATUS_STONE &lt;- 7           //  石化\n                ACTIVESTATUS_SLEEP &lt;- 8           //  睡眠\n                ACTIVESTATUS_BURN &lt;- 9           //  燃烧\n                ACTIVESTATUS_WEAPON_BREAK &lt;- 10           //  武器破甲\n                ACTIVESTATUS_BLEEDING &lt;- 11           //  出血\n                ACTIVESTATUS_HASTE &lt;- 12           //  加速\n                ACTIVESTATUS_BLESS &lt;- 13           //  祝福\n                ACTIVESTATUS_ELEMENT &lt;- 14           //  엘레먼트\n                ACTIVESTATUS_CONFUSE &lt;- 15           //  混乱\n                ACTIVESTATUS_HOLD &lt;- 16           //  束缚\n                ACTIVESTATUS_ARMOR_BREAK &lt;- 17           //  护甲破甲\n                ACTIVESTATUS_MAX &lt;- 18\n\n\n//直接发送攻击包\nsq_SendHitObjectPacket(obj,object,0,0,sq_GetObjectHeight(obj) / 2);//发送攻击包\n\nsq_SendHitObjectPacketWithNoStuck(obj,damager,0,0,0);//发送不会未命中的攻击包\n\n//按照自己的自定义攻击信息发送攻击 （这个没测试出来该怎么用  可能没有效果。。）\nsq_SendHitObjectPacketByCustomAttackIndex(obj,damager,0,0,0,0);\n\nnew一个新的攻击信息包，其实是召唤特效，如果攻击次数过多不建议创建这个\n//新建一个攻击包\nlocal ap = sq_getNewAttackInfoPacket();\nap.hitStunTimeAttackerDamager = stunTime;//僵直时间\nap.sizeRate = sizeRate;//攻击大小\nap.changeStatusType = changeStatusType; //异常状态类型\nap.changeStatusProb = changeStatusProb.tofloat();  //异常状态概率\nap.changeStatusLevel = changeStatusLevel.tofloat(); //异常状态等级    \nap.changeStatusDuration = changeStatusDuration;//异常状态持续时间\nap.changeStatusdamage = changeStatusdamage;//异常状态伤害\nap.power = fireDamage;//固伤\nap.powerRate = attackPower;//百分比\nap.element = ENUM_ELEMENT_FIRE;//属性\nap.useWeapon = false;//是否吃武器伤害\nap.eType = ATTACKTYPE_MAGICAL;//攻击类型 魔法还是物理\nap.stuckRate = 100.0;//命中率\nap.backForce = 100;//推开距离\nap.upForce = 100;//打击高度\nap.knockBackType = 100;//没测试过\nsq_SendHitObjectPacketByAttackInfo(parentObj, attacker, ap);//以新的攻击包发送攻击\nsq_createCommonElementalAttack(obj, elementalType, 0, 0, 0, explosionInfo);//待测试\n\n\n//应用基本攻击 #没测试过\nmage.applyBasicAttackUp(sq_GetCurrentAttackInfo(obj),mage.getState());    \nsq_SetCurrentAttackInfo(obj,sq_GetCurrentAttackInfo(obj));\n\n//坐标 方向 距离 移动常用相关\n//方向常量\nENUM_DIRECTION_LEFT &lt;- 0 //左方向\nENUM_DIRECTION_RIGHT &lt;- 1 //右方向\nENUM_DIRECTION_UP &lt;- 2 //上方向\nENUM_DIRECTION_DOWN &lt;- 3 //下方向\nENUM_DIRECTION_NEUTRAL &lt;- 4 //中心\nENUM_DIRECTION_MAX &lt;- 5\nabs函数 #运算得到的结果无论如何都会得到正数结果\nsq_Abs(600 - 900);\nAtan2三角函数 #长度高度算出靠近高度的弧度\nlocal atan = sq_Atan2(x.tofloat(), z.tofloat());\nDegree函数 #将弧度转为角度\nlocal angle = sq_ToDegree(atan);\nRadian函数 #角度转为弧度\nsq_ToRadian(angle);\nCos函数 #给角度值计算出长度距离 #一般用于圆形的长度运算\nsq_Cos(angle);\nsq_CosTable(angle);\nSin函数 #给角度值计算出高度比率 #一般用于弧形的高度\nsq_Sin(angle);\nsq_SinTable(angle);\n寻找范围内的单一目标\n//角色用这个\nlocal targetObj = sq_FindTarget(obj, 80, x_range, y_range, z_range);//对象 初始x 结束x  上下y范围 z范围 也是默认找第一个找到的\n\n//特效用这个\nlocal targetObj = obj.sq_FindFirstTarget(start_x, start_end_x, y_range, z_range);//寻找距离近的第一个目标\nlocal targetObj = obj.sq_FindNextTarget(pActiveTarget, next_x_range, z_range);//寻找下一个目标\n\n//寻找射击目标\nlocal activeObject = sq_FindShootingTarget(obj, sq_GetDistancePos(sq_GetXPos(obj),obj.getDirection(),x), sq_GetYPos(obj), sq_GetZPos(obj) + z, 0, 0, 4, 14, -1, 300, 100, 50, 100);\n//按角度找目标 男魔法的函数\nlocal targetObj = findAngleTarget(obj, distance, angle, 100);\n根据时间计算的坐标模板 常用\n//按照时间 来进行移动；移动较为准确\n\nlocal pAni = obj.getCurrentAnimation();//得到ani\nlocal currentT = sq_GetCurrentTime(pAni);//当前时间\nlocal fireT = pAni.getDelaySum(0, 0);//总时间\n\nlocal srcX = obj.getVar().get_vector(0);//初始x坐标\nlocal srcY = obj.getVar().get_vector(1);//初始y坐标\nlocal srcZ = obj.getVar().get_vector(2);//初始z坐标\n\nlocal MoveX = obj.getVar().get_vector(3);//移动多少x距离\nlocal MoveY = obj.getVar().get_vector(4);//移动多少y距离\nlocal MoveZ = obj.getVar().get_vector(5);//移动多少z距离\n\nlocal v = sq_GetUniformVelocity(0, MoveX, currentT, fireT);\nlocal dstX = sq_GetDistancePos(srcX, obj.getDirection(), v);//根据方向运算当前数值\n\nsq_setCurrentAxisPos(obj, 0, dstX);//设置当前x坐标\nsq_setCurrentAxisPos(obj, 1, dstY);//设置当前y坐标\nsq_setCurrentAxisPos(obj, 2, dstZ);//设置当前z坐标\n\n寻找地平线 垂直角度\n\n//得到地平线的角度\nlocal horizonAnglez = sq_GetShootingHorizonAngle(activeObject, y, 0, searchAngleH, maxDistance);\n//得到垂直角度\nlocal verticalAnglez = sq_GetShootingVerticalAngle(activeObject, z, 0, searchAngleV, maxDistance,300);\n//寻找到角度后一般都给ptl使用\n\n得到  设置坐标pos\n//对象类\nobj.getXPos();//x坐标\nobj.getYPos();//y坐标\nobj.getZPos();//z坐标\n\n//任意对象\nsq_GetXPos();//x坐标\nsq_GetYPos();//y坐标\nsq_GetZPos();//z坐标\nlocal screenX = sq_GetScreenXPos(object);//位于屏幕x坐标\nlocal screenY = sq_GetScreenYPos(object);//位于屏幕y坐标\n//玩家\nlocal mouseX = sq_GetMouseXPos();//鼠标x坐标\nlocal mouseY = sq_GetMouseYPos();//鼠标y坐标\n\n\n//对象类\npooledObj.setCurrentPos(x,y,z);\n\n//任意对象\nsq_SetCurrentPos(obj,x,y,z);\n\n//设置单个x或y或z坐标\nsq_setCurrentAxisPos(obj, 0, dstX);//设置当前x坐标\nsq_setCurrentAxisPos(obj, 1, dstY);//设置当前y坐标\nsq_setCurrentAxisPos(obj, 2, mz);//设置当前z坐标\n\n得到 设置方向\n\nlocal direction = obj.getDirection();//得到方向 对象类\nlocal direction = sq_GetDirection(obj);//得到方向\n\nlocal direction = obj.sq_GetInputDirection(0);//得到输入的方向?\n\nsq_SetCurrentDirection(pooledObj, obj.getDirection());//设置方向\nobj.setDirection(ENUM_DIRECTION_RIGHT);//设置方向 对象类\n\nsq_GetOppositeDirection(direction);//得到相反的方向\n\n//设置相反方向\nsq_SetCurrentDirection(obj, sq_GetOppositeDirection(sq_GetDirection(obj)));//设置相反方向\n\n//根据方向得到坐标\nlocal dstX = sq_GetDistancePos(srcX, obj.getDirection(), v);//根据方向得到坐标\n//根据比率得到结果值 #根据当前时间跟总时间以及当前位置跟到达位置按照比率得到现在的数值\nlocal v = sq_GetUniformVelocity(0, MoveX, currentT, fireT);//此函数为均匀平均的移动\nlocal v = sq_GetAccel(0, dis_x_len, currentT, dash_t, true);//此函数为先快后慢或先慢后快移动 最后一个参数 改为true快到慢 false慢到快\n参数1；为初始位置  \n参数2：为结束位置\n参数3：当前的时间\n参数4：限制的总时间\n可以分两种来进行移动；不过都是在被动proc函数中进行\n第一种：\n可以设置移动多少距离来计算；计算完成后再加上初始坐标，就可以得出当前需要移动到哪里\n第二种：\n可以设置初始跟结束位置，会自动计算出结果坐标；再直接进行移动即可\n\n//下面是找花花要的一个弧线运行的函数\nfunction getQuadraticFunction(obj,x,b,c)\n{\n  local a = (-b.tofloat() * 4) /( c.tofloat() * c.tofloat());\n  return a.tofloat()*(x.tofloat() - c.tofloat() / 2)*(x.tofloat() - c.tofloat() / 2) + b.tofloat();\n}\n//结果要转为整数型\n//参数1：对象\n//参数2：0+ 0初始百分比   36到达百分比   height高度或者距离  100总百分比\nlocal vz = getQuadraticFunction(obj,0 + sq_GetAccel(0, 36, currentT, delayT, true) ,height,100).tointeger();\n\n//再或者这样写 弧度运行\nlocal h = sq_GetUniformVelocity(0, 180, currentT, fireT);//得到角度\nlocal vZ = 高度 * sq_SinTable(h) ;//得到弧形高度\n\n根据两个x y点得到对角线距离\nlocal distance = sq_GetDistance( X, Y - Z, posX, posY - posZ, true);//得到对角线距离\n\nsq_GetDistanceObject(obj, object, true);//得到距离对象\n\n//开平方根得到距离\nsqrt(\n(x1-x2)*(x1-x2)+\n(y1-y2)*(y1-y2)\n);\n\n\n单个得到x或y距离\nobj.getXDistance(pChr);//对象类 得到x距离\nobj.getYDistance(pChr);//对象类 得到y距离\n\nlocal posX = CNRDObject.getAngleDistanceXPos(obj.getVar(\"pos\").get_vector(0), angle, radius, ENUM_DIRECTION_RIGHT);\nlocal posY = CNRDObject.getAngleDistanceYPos(obj.getVar(\"pos\").get_vector(1), angle, radius, false);\n\n//坐标是否可到达\nobj.isMovablePos(dstX, dstY);//活动类 对象\n人物单纯的设置移动速度\n//单纯的速度移动\n//参数1:0为x轴 1为y轴 2为z轴\n//参数2，3：为速度区间\n//参数4，true 则按键才可移动  false则不能按键移动\n//参数5：为加速；如果要移动固定距离 则速度*6为加速数值 可以移动到固定地点\n//参数6：true 快到慢 false慢到快\nobj.sq_SetStaticMoveInfo(0, xVelocity, xVelocity, false, xAccel, true);\nobj.sq_SetStaticMoveInfo(1, 0, 0, false);\nobj.sq_SetMoveDirection(obj.getDirection(), ENUM_DIRECTION_NEUTRAL);//开始移动\n设置z的移动速度\n//已z坐标移动 正数为上  负数为下\nsq_SetZVelocity(obj,100,100);\n设置速度 #xyz速度\nsq_SetVelocity(obj, 0, 1500.0);\n//参数1：对象\n//参数2：类型 0x轴 1y轴 2z轴 不吃方向\n//参数3：速度值\n停止移动或停止z移动\nobj.sq_ZStop();//停止z移动\nobj.sq_StopMove();//停止移动\n常用抓取 #判断目标是否可抓取或者可控制 #并且附加控制或者移动ap\nsq_IsHoldable(obj,damager);//是否可控制\nsq_IsFixture(damager);//是否是固定的\nsq_IsGrabable(obj,damager);//是否可以抓取\n\nsq_SetGrabable(obj, false);//设置是否可抓取\n\n\n//控制 并且 延时死亡；参数3：是否控制 参数4：是否延时死亡 参数5：销毁ap时是否击飞 参数6：击飞距离 参数7：击飞高度\nsq_HoldAndDelayDie(damager, obj, true, true, true, 200, 200, ENUM_DIRECTION_NEUTRAL , masterAppendage);\n//使敌人目标按照时间 自动达到指定位置\nsq_MoveToAppendageForce(ChrJob, obj, obj, 160, 0, ChrJob.getZPos(), 3000, false, null);\n//速度快到慢\nsq_AccelMoveToAppendageForce(aoDamager, obj, obj, x, 0, z - aoDamager.getObjectHeight()/2, liftTime, true, masterAppendage,true);\n//寻找一个可以移动的坐标并移动过去\nsq_MoveToNearMovablePos(obj,chrx ,chry , 350, objx, objy, 350, 100, -1, 5);\n\n\n//吸怪 只能附加到活动类对象，角色或怪物\n//参数1：我自己 参数2：吸附范围 参数3：以我自身x轴偏移到的吸附中心点  参数4：吸附强度\nlocal appendage = sq_AttractToMe(obj, 200, 100, attractPower);\nobj.getVar().setAppendage(0,appendage);//设置ap\nlocal appendage = obj.getVar().getAppendage(0);//得到ap\n    if(appendage)//为真\n        appendage.setValid(false);//删除ap\n\n\n//这个暂时没测试 好像是直接把某个目标给拉过来\nsq_AtrractionForce(obj, damager, false, 270, -1, 2000.0, 1500.0, false); // 밀어내기    \n\n跟随移动 #且可以获得跟随移动目标的状态以及技能使用状态\nsq_moveWithParent(obj, pooledObj);//跟随移动 参数1：被跟随的对象 参数2：要跟随的对象\nlocal moveParent = sq_GetMoveParent(obj);//得到跟随的对象\nlocal parentState = obj.sq_GetParentState();//特效类 得到跟随者的状态\nlocal subState = obj.sq_GetParentSkillSubState();//特效类 得到跟随者的技能使用状态\n\n角色设置寻找到的新的可以移动的位置 #防止卡墙\nsq_SimpleMoveToNearMovablePos(obj,200);//直接防止卡墙\n\n//参数1：起始寻找的x坐标\n//参数2：起始寻找的y坐标\n//参数3：寻找的x坐标范围\n//参数4：寻找的y坐标范围\n//参数5：寻找的偏移？\nobj.sq_SetfindNearMovablePos(obj.getXPos(),obj.getYPos(),50,1,5);\n\n寻找一个可以移动的x或y坐标\n//对象类\n//参数1：起始寻找的x坐标\n//参数2：起始寻找的y坐标\n//参数3：结束寻找的x坐标\n//参数4：结束寻找的y坐标\n//参数5：偏移\ndamager.sq_findNearLinearMovableXPos(x, y, obj.getXPos(), y, 10);\ndamager.sq_findNearLinearMovableYPos(x, y, obj.getXPos(), y, 10);\n\n男魔法的圆形移动函数算法 #圆形移动解刨\nlocal currentT  = sq_GetObjectTime(ani);//当前时间\nlocal currentSpeedRate = 1.0;//额外计算的 速度率\nlocal defaultRoundTime = 3000;//每隔多少秒转一圈\nlocal radius = 100;//旋转半径 总长度 半径*2\nlocal base100Angle = 18000;//初始角度 这里应该是角度*100 最大角度是360\n\nlocal baseX = obj.getXPos()+300;//初始x坐标\nlocal baseZ = obj.getZPos()+200; // 初始z坐标\n\nlocal current100Angle = (base100Angle + (36000 * currentSpeedRate * currentT / defaultRoundTime)) % 36000;//根据当前时间跟总时间 跟初始角度计算出当前角度\nlocal angle = (current100Angle.tofloat() / 100.0);//除以100 得到正常角度\nlocal disMovLen = radius * sq_CosTable(angle.tointeger());//根据角度计算圆形的长度\nlocal mov_x = sq_GetDistancePos(baseX, sq_GetOppositeDirection(obj.getDirection()), disMovLen.tointeger());//按照对象方向跟初始坐标得到 目标x坐标\nlocal axisMagnifyRate = 100;//半径//圆形高度的比率\nlocal upMovLen = radius * sq_SinTable(angle.tointeger()) * axisMagnifyRate / 100;//得到圆形的高度\nlocal mov_y = baseZ + upMovLen.tointeger();//得到要移动的y坐标\n//下面的判断是\n//移动的x坐标 不等于 初始x坐标减去100的话就移动x坐标 不过好像每什么用\nif(mov_x!=baseX-100)\nsq_setCurrentAxisPos(ani, 0, mov_x);\nsq_setCurrentAxisPos(ani, 2, mov_y);\n\n按键相关  连续输入 #连续按键判断之类\n按下并弹起判断\nobj.setSkillCommandEnable(SKILL_MULTI_SHOT,true);//激活技能使图标变亮\nlocal b_useskill = obj.sq_IsEnterSkill(SKILL_MULTI_SHOT);//判断是否按下技能键 返回值不等于-1代表按下\n\nE_ATTACK_COMMAND &lt;- 0//攻击键\nE_JUMP_COMMAND &lt;- 1//跳跃键\nE_DASH_COMMANDS_1 &lt;- 2//右方向键\nE_DASH_COMMANDS_2 &lt;- 3//左方向键\nE_CREATURE_COMMAND &lt;- 4//宠物技能键\nE_BUFF_COMMAND &lt;- 5//buff技能键\nE_SKILL_COMMAND &lt;- 6//技能键 z\nE_COMMAND_COUNT &lt;- 7//没有这个 用这个会掉线\nsq_SetKeyxEnable(obj, E_ATTACK_COMMAND, true);//设置其他按键\nsq_IsEnterCommand(obj, E_ATTACK_COMMAND);//为真确认按下\n\n按下按键判断\n\nlocal isVertical = sq_IsKeyDown(OPTION_HOTKEY_MOVE_DOWN, ENUM_SUBKEY_TYPE_ALL);\n\n//按下我的前方\nif(sq_IsKeyDown(OPTION_HOTKEY_MOVE_LEFT, ENUM_SUBKEY_TYPE_ALL) &amp;&amp; obj.getDirection()== ENUM_DIRECTION_LEFT\n            ||sq_IsKeyDown(OPTION_HOTKEY_MOVE_RIGHT, ENUM_SUBKEY_TYPE_ALL) &amp;&amp; obj.getDirection()== ENUM_DIRECTION_RIGHT)\n\n//按下我的后方\nif(sq_IsKeyDown(OPTION_HOTKEY_MOVE_LEFT, ENUM_SUBKEY_TYPE_ALL) &amp;&amp; obj.getDirection()== ENUM_DIRECTION_RIGHT\n            ||sq_IsKeyDown(OPTION_HOTKEY_MOVE_RIGHT, ENUM_SUBKEY_TYPE_ALL) &amp;&amp; obj.getDirection()== ENUM_DIRECTION_LEFT)\n\n\nOPTION_HOTKEY__UNDEFINED &lt;- -1     //  정의되지 않음\nOPTION_HOTKEY_MOVE_UP &lt;- 0     //  (Up arrow)\nOPTION_HOTKEY_MOVE_LEFT &lt;- 1     //  (Left arrow)\nOPTION_HOTKEY_MOVE_DOWN &lt;- 2     //  (Down arrow)\nOPTION_HOTKEY_MOVE_RIGHT &lt;- 3     //  (Right arrow)\nOPTION_HOTKEY_ATTACK &lt;- 4     //  (X)\nOPTION_HOTKEY_JUMP &lt;- 5     //  (C)\nOPTION_HOTKEY_SKILL &lt;- 6     //  (Z)\nOPTION_HOTKEY_SKILL2 &lt;- 7     //  buff용 키(space)\nOPTION_HOTKEY_CREATURE_SKILL &lt;- 8     //  (V)\nOPTION_HOTKEY_STATUS_WINDOW &lt;- 9     //  (M)\nOPTION_HOTKEY_SKILL_WINDOW &lt;- 10     //  (K)\nOPTION_HOTKEY_ITEM_INVENTORY &lt;- 11     //  (I)\nOPTION_HOTKEY_OPTION_WINDOW &lt;- 12     //  (O)\nOPTION_HOTKEY_NORMAL_QUEST_WINDOW &lt;- 13     //  (Q)\nOPTION_HOTKEY_AVATAR_INVENTORY &lt;- 14     //  (U)\nOPTION_HOTKEY_CERASHOP &lt;- 15     //  (T)\nOPTION_HOTKEY_MINIMAP &lt;- 16     // 던전 미니맵(N)\nOPTION_HOTKEY_CREATURE_WINDOW &lt;- 17     //  (Y)\nOPTION_HOTKEY_TOOLTIP_ &lt;- 18     // 상세보기 전환키(R)\nOPTION_HOTKEY_EPIC_QUEST_WINDOW &lt;- 19     //  (W)\nOPTION_HOTKEY_QUICK_SKILL1 &lt;- 20     //  스킬 슬롯(A, S, D, F, G, H)\nOPTION_HOTKEY_QUICK_SKILL2 &lt;- 21 \nOPTION_HOTKEY_QUICK_SKILL3 &lt;- 22 \nOPTION_HOTKEY_QUICK_SKILL4 &lt;- 23 \nOPTION_HOTKEY_QUICK_SKILL5 &lt;- 24 \nOPTION_HOTKEY_QUICK_SKILL6 &lt;- 25 \nOPTION_HOTKEY_EXSKILL1 &lt;- 26     //  확장스킬 슬롯(F1 - F6)\nOPTION_HOTKEY_EXSKILL2 &lt;- 27 \nOPTION_HOTKEY_EXSKILL3 &lt;- 28 \nOPTION_HOTKEY_EXSKILL4 &lt;- 29 \nOPTION_HOTKEY_EXSKILL5 &lt;- 30 \nOPTION_HOTKEY_EXSKILL6 &lt;- 31 \nOPTION_HOTKEY_ITEM_QUICKSLOT1 &lt;- 32     //  아이템 퀵 슬롯(1 - 6)\nOPTION_HOTKEY_ITEM_QUICKSLOT2 &lt;- 33 \nOPTION_HOTKEY_ITEM_QUICKSLOT3 &lt;- 34 \nOPTION_HOTKEY_ITEM_QUICKSLOT4 &lt;- 35 \nOPTION_HOTKEY_ITEM_QUICKSLOT5 &lt;- 36 \nOPTION_HOTKEY_ITEM_QUICKSLOT6 &lt;- 37 \nOPTION_HOTKEY_TOGGLE_ITEM_NAME_IN_DUNGEON &lt;- 38     //  던전에서 아이템 이름보기(ctrl)\nOPTION_HOTKEY_HIDE_MAIN_HUD &lt;- 39     //  인터페이스 숨기기(Tab)\nOPTION_HOTKEY_TOGGLE_TITLE_ANIMATION &lt;- 40     //  닉네임 정보 모드 변환(E)\nOPTION_HOTKEY_TOGGLE_SKILL_INFORMATION &lt;- 41     //  스킬 툴팁 설명 모드 전환(F7)\nOPTION_HOTKEY_PAUSE_IN_TOWER &lt;- 42     //  사망의 탑 일시정지\nOPTION_HOTKEY_CAPTURE_MOVING_PICTURE &lt;- 43     //  동영상 캡쳐(Pause)\nOPTION_HOTKEY_MENU_MY_INFO &lt;- 44     //  내보관함 메뉴(7)\nOPTION_HOTKEY_MENU_COMMUNITY &lt;- 45     //  커뮤니티 메뉴(8)\nOPTION_HOTKEY_MENU_CONTENTS &lt;- 46     //  컨텐츠 메뉴(9)\nOPTION_HOTKEY_MENU_SERVICE &lt;- 47     //  서비스 메뉴(0)\nOPTION_HOTKEY_MENU_SYSTEM__CLOSE_ALL_WINDOW &lt;- 48     // 모든창닫기(Esc)\nOPTION_HOTKEY_PVP &lt;- 49     //  결투장(P)\nOPTION_HOTKEY_RECOMMEND_USER &lt;- 50     //  추천동료([)\nOPTION_HOTKEY_PARTY_MATCHING &lt;- 51     //  파티매칭(])\nOPTION_HOTKEY_FRIEND &lt;- 52     //  친구(L)\nOPTION_HOTKEY_GUILD &lt;- 53     //  길드(;)\nOPTION_HOTKEY_MEMBER &lt;- 54     //  멤버(')\nOPTION_HOTKEY_BLACKLIST &lt;- 55     //  차단\nOPTION_HOTKEY_PVP_BUDDY &lt;- 56     //  결투친구\nOPTION_HOTKEY_WAR_AREA_LIST &lt;- 57     //  전쟁지역목록창(,)\nOPTION_HOTKEY_AUCTION_WINDOW &lt;- 58     //  경매장(B)\nOPTION_HOTKEY_GOBLIN_PAD &lt;- 59     //  고블린패드\nOPTION_HOTKEY_HOTKEY_SETTING_WINDOW &lt;- 60     //  단축키 설정창\nOPTION_HOTKEY_WAR_AREA_INFORMATION &lt;- 61     //  전쟁지역 정보창(End)\nOPTION_HOTKEY_HELLMODE_INFORMATION &lt;- 62     //  더 이상 사용되지 않음\nOPTION_HOTKEY_FAVOR_CHECK_WINDOW &lt;- 63     //  더 이상 사용되지 않음\nOPTION_HOTKEY_EXPERT_JOB &lt;- 64     //  전문직업 기능\nOPTION_HOTKEY_EMOTION_EXPRESSION &lt;- 65     //  감정표현 기능\nOPTION_HOTKEY_EVENT &lt;- 66     //  이벤트키(shift)\nOPTION_HOTKEY_PVP_MSSION &lt;- 67     //  미션윈도우\nOPTION_HOTKEY_PVP_RECORD &lt;- 68     //  전적보기창\nOPTION_HOTKEY_QUICK_CHAT_0 &lt;- 69 \nOPTION_HOTKEY_QUICK_CHAT_1 &lt;- 70 \nOPTION_HOTKEY_QUICK_CHAT_2 &lt;- 71 \nOPTION_HOTKEY_QUICK_CHAT_3 &lt;- 72 \nOPTION_HOTKEY_QUICK_CHAT_4 &lt;- 73 \nOPTION_HOTKEY_QUICK_CHAT_5 &lt;- 74 \nOPTION_HOTKEY_QUICK_CHAT_6 &lt;- 75 \nOPTION_HOTKEY_QUICK_CHAT_7 &lt;- 76 \nOPTION_HOTKEY_QUICK_CHAT_8 &lt;- 77 \nOPTION_HOTKEY_QUICK_CHAT_9 &lt;- 78 \nOPTION_HOTKEY_TOGGLE_ITEMINFO_COMPARE &lt;- 79     //  아이템 비교창 전환키 (Default: F8)\nOPTION_HOTKEY_TITLEBOOK &lt;- 80     //  칭호북\nOPTION_HOTKEY_THIS_DUNGEON &lt;- 81     //  재도전\nOPTION_HOTKEY_ANOTHER_DUNGEON &lt;- 82     //  다른 던전 도전\nOPTION_HOTKEY_RETURN_TO_TOWN &lt;- 83     //  마을로 돌아가기\nOPTION_HOTKEY_MERCENARY_SYSTEM &lt;- 84     //  용병 시스템\nOPTION_HOTKEY_ITEM_DICTIONARY &lt;- 85 \nOPTION_HOTKEY_QUICK_PARTY_REGISTER &lt;- 86     //  빠른 파티 등록 요청\n\n//蓄力\nobj.sq_IsEnterSkillLastKeyUnits(SKILL_FIREPILLAR);//可以蓄力\nobj.isDownSkillLastKey();//判断是否按下技能键键\n//开始快速输入？ #没怎么测试\n//输入频率？\nobj.startRapidInput();\nobj.getRapidInputFrequency();\n//用法一：\n//每次记录按下键时 就增加一次连续输入\nobj.addRapidInput();//增加连续输入记录\n//用此函数可以得到按下了多少次\nobj.getRapidInputFrequency();//得到连续的按键信息\n\n//技能负载 画ui\n//增加技能负载\nobj.sq_AddSkillLoad(SKILL_ATGUNNER_HS12, 50, 1, 500);//技能编号，img序号，可以使用几次，冷却时间\n//删除技能负载\nobj.sq_RemoveSkillLoad(SKILL_ATGUNNER_HS12);//技能编号\n\n//得到技能负载\nlocal loadSlot = obj.sq_GetSkillLoad(SKILL_ATGUNNER_HS12);\n//判断是否在冷却中\nloadSlot.isCooling();\n//使用几次\nloadSlot.use(1);\n//得到剩余装载数\nloadSlot.getRemainLoadNumber();\n//开始冷却\nloadSlot.setStartCool();\n//得到总冷却时间\nloadSlot.getEndCoolTime();\n//得到现在的冷却时间、\nloadSlot.getCurrentCoolTime();\n//得到icon ID\nloadSlot.getInconIndex();\n\n//icon图标路径 //台服最多不能超过50\nsprite/character/common/customui/icon.img\n\n//ptl设置 创建 更改相关\n//特效增加 删除 设置移动ptl\nobj.sq_SetMoveParticle(\"Particle/ATWaterCannonMove.ptl\", 0.0, 0.0);//设置移动的ptl 路径是特效的路径为父路径\n\nobj.sq_RemoveMoveParticle();//删除特效身上的移动ptl\n\n//参数1：特效对象\n//参数2：移动类型 0：x坐标  1：y坐标 2：z坐标\n//参数3：速度值\nsq_SetSpeedToMoveParticle(obj,0,speed);//设置移动速度\n\nobj.sq_AddObjectParticleCreater(\"Particle/ATWaterCannonTail.ptl\");//增加额外的ptl\nobj.sq_SetObjectParticlePos(0, 1, 0);//设置创建ptl的x y z轴坐标\n\n//增加一个以map为坐标的ptl\nlocal particleCreater = obj.sq_var.GetparticleCreaterMap(\"ATWaterCannon\",\"PassiveObject/Character/Mage/Particle/ATWaterCannonTail.ptl\", obj);//得到ptl\nparticleCreater.Restart(0);//重置\nparticleCreater.SetPos(x, y, z);//设置xyz\nsq_AddParticleObject(obj, particleCreater);//增加ptl对象\n\n//创建ptl 删除ptl\n//参数1：路径\n//参数2：对象\n//参数3：x偏移（方向为右）\n//参数4：y偏移\n//参数5：z偏移\n//参数6：是否跟随 参数2对象移动 bool值\n//参数7：创建间隔\n//参数8：最长存在时间\n//参数9：最大创建次数\nsq_CreateParticle(\"Character/Priest/Effect/Particle/ExcutionStonsLarge.ptl\", obj, 180, 5, 250, true, 30, 0, 2);//创建ptl\n\nsq_RemoveParticle(\"PassiveObject/Character/Mage/Particle/ATIceOrbDust.ptl\",obj);//删除ptl\n\n\n//未知 没测试\nsq_CreateParticleByGlobal(obj.getDustParticleType(LANDPARTICLE_MOVE), obj, x, 0, 0, true, 80, 120, 5);    \n\n\n        sq_CreateParticleByGlobal(PARTICLE_CREATER_WATER_HIT_LIGHT,    // ENUM_PARTICLE_CREATER\n\n                        obj,        // CNRDObject* master,\n                                0,            //int x,\n                                -1,            //int y,\n                                0,            //int z,\n                        true,        //bool posistionFromMaster,\n                                30,            //int timeGap,\n                        150,        //int maxTime,\n\n                                        5);        //int maxCount\n\n\n//得到鼠标，控制鼠标                                        \n//得到鼠标位置 设置鼠标位置    \n        local Mouse = IMouse();//得到鼠标类\n        Mouse.GetXPos();//得到鼠标x坐标\n        Mouse.GetYPos();//得到鼠标x坐标\n        Mouse.SetXPos(400);//设置鼠标x坐标\n        Mouse.SetYPos(300);//设置鼠标y坐标\n        Mouse.SetPos(400,300);//设置鼠标x,y坐标 游戏程序一直运行 他就会一直设置鼠标坐标\n        Mouse.SetPosBasedOnGameWindow(400,200);//设置鼠标x,y坐标 游戏窗口获取焦点后才会改变鼠标坐标\n\n//是否处于异常状态下  删除异常状态\nsq_ReleaseActiveStatus(sqrObj, ACTIVESTATUS_POISON);//删除异常状态\n\n//判断前先转为活动类对象\nif (sq_IsValidActiveStatus(obj, ACTIVESTATUS_STUN))\n{\n        //  STUN 걸려있으면 해제시킴. STATE_STAND로 돌아가지 않게 disable시킴\n        obj.setEnableChangeState(false);\n        sq_IsSetActiveStatus(obj, ACTIVESTATUS_STUN, 0.0);\n        obj.setEnableChangeState(true);\n}\nACTIVESTATUS_SLOW &lt;- 0 // 减速\nACTIVESTATUS_FREEZE &lt;- 1 // 冰冻\nACTIVESTATUS_POISON &lt;- 2 // 中毒\nACTIVESTATUS_STUN &lt;- 3 // 眩晕\nACTIVESTATUS_CURSE &lt;- 4 // 诅咒\nACTIVESTATUS_BLIND &lt;- 5 // 失明\nACTIVESTATUS_LIGHTNING &lt;- 6 // 感电\nACTIVESTATUS_STONE &lt;- 7 // 石化\nACTIVESTATUS_SLEEP &lt;- 8 // 睡眠\nACTIVESTATUS_BURN &lt;- 9 // 燃烧\nACTIVESTATUS_WEAPON_BREAK &lt;- 10 // 武器破甲\nACTIVESTATUS_BLEEDING &lt;- 11 // 出血\nACTIVESTATUS_HASTE &lt;- 12 // 加速\nACTIVESTATUS_BLESS &lt;- 13 // 祝福\nACTIVESTATUS_ELEMENT &lt;- 14 // 엘레먼트                \nACTIVESTATUS_CONFUSE &lt;- 15 // 混乱\nACTIVESTATUS_HOLD &lt;- 16 // 束缚\nACTIVESTATUS_ARMOR_BREAK &lt;- 17 // 护甲破甲\nACTIVESTATUS_MAX &lt;- 18\n\n//得到对象，ani，状态时间\nlocal time = sq_GetObjectTime(obj);//得到对象时间\nlocal stateTime = obj.sq_GetStateTimer();//角色类 得到状态时间\nlocal currentT = sq_GetCurrentTime(pAni);//ani得到当前时间\n\n//重置攻击\nobj.resetHitObjectList();//重置攻击 控制类对象\n\n//是否处于可攻击到状态 #判断怪物是否可以被攻击到\nobject.isInDamagableState(obj);//控制类对象\n//增加攻击对象 #把对象加入到我的攻击列表中 #代表我已攻击到\nsq_AddHitObject(obj, damager);//增加攻击对象\n\n//如果没有效果 可以转为活动类 或者 控制类对象后加入\n\n\n//震动 闪屏\nsq_SetMyShake(obj,8,300);//震动 只有我自己震动\nsq_SetShake(obj,6,400);//震动 所有人都可以看到的震动\n\n//闪屏\n//参数说明：\n//1.对象\n//2.出现的时间\n//3.持续的时间\n//4.消失的时间\n//5.透明度：255不透明  0透明看不见\n//6.rgb颜色值\n//7.颜色效果\n//8.闪屏图层；可设置最顶层或底层\nsq_flashScreen(obj,80,100,240,150, sq_RGB(0,0,0), GRAPHICEFFECT_NONE, ENUM_DRAWLAYER_BOTTOM);//闪屏\n//加入到对象后；可以清除\nlocal flashScreenObj = sq_flashScreen(obj,80,99990,240,150, sq_RGB(0,0,0), GRAPHICEFFECT_NONE, ENUM_DRAWLAYER_BOTTOM);\nobj.getVar(\"flashobj\").clear_obj_vector();//清除\nobj.getVar(\"flashobj\").push_obj_vector(flashScreenObj);//加入\nlocal flashScreenObj = obj.getVar(\"flashobj\").get_obj_vector(0);//得到\nlocal pflashScreen = sq_GetCNRDObjectToFlashScreen(flashScreenObj);//转为闪屏类\nif(pflashScreen) pflashScreen.fadeOut();//为真 销毁\n\nlocal fScreen = sq_flashScreen(obj,0,80,0,80, sq_RGB(255,255,255), GRAPHICEFFECT_NONE, ENUM_DRAWLAYER_BOTTOM);\nsq_addFlashScreen(fScreen, 0, 240, 240, 150, sq_RGB(0,0,0), GRAPHICEFFECT_NONE, ENUM_DRAWLAYER_BOTTOM);\n\n//常量\n\n\n                GRAPHICEFFECT_NONE &lt;- 0           //  橈擠\n                GRAPHICEFFECT_DODGE &lt;- 1           //  游雖\n                GRAPHICEFFECT_LINEARDODGE &lt;- 2           //  葬棲橫 游雖\n                GRAPHICEFFECT_DARK &lt;- 3           //  棻觼\n                GRAPHICEFFECT_XOR &lt;- 4           //  XOR\n                GRAPHICEFFECT_MONOCHROME &lt;- 5           //  欽儀\n                GRAPHICEFFECT_SPACE_DISTORT &lt;- 6           //  奢除諼堊\n                GRAPHICEFFECT_MAX &lt;- 7 \n\n                ENUM_DRAWLAYER_CONTACT &lt;- 0           //  蕾唳 溯檜橫\n                ENUM_DRAWLAYER_NORMAL &lt;- 1           //  橾奩 溯檜橫\n                ENUM_DRAWLAYER_BOTTOM &lt;- 2           //  夥款 溯檜橫\n                ENUM_DRAWLAYER_CLOSEBACK &lt;- 3           //  斬唳 溯檜橫\n                ENUM_DRAWLAYER_MIDDLEBACK &lt;- 4           //  醞唳 溯檜橫\n                ENUM_DRAWLAYER_DISTANTBACK &lt;- 5           //  錳唳 溯檜橫\n                ENUM_DRAWLAYER_COVER &lt;- 6           //  賊擊 竣朝 溯檜橫 ex : Blind\n                ENUM_DRAWLAYER_MAX &lt;- 7 \n​\n\n\n//播放声音\n\n//播放声音；参数为客户端xml文件内的声音ID\nobj.sq_PlaySound(\"SM_BLOODBOOM_02\");//播放声音\n//播放声音，并且赋予ID值\nobj.sq_PlaySound(\"ICEORB_THORN_LOOP\",3711);//播放循环的声音\n//停止播放\nobj.stopSound(3711);//停止播放\n\n//创建特效\n\n//角色创建特效  方向跟坐标都是以角色偏移   参数分别是：特效编号，等级，x偏移，y偏移，z偏移\nobj.sq_SendCreatePassiveObjectPacket(24201, 0, 120, 1, 0);\n\n//创建特效 参数分别是：对象，特效编号，等级，x偏移，y偏移，z偏移，方向\nsq_SendCreatePassiveObjectPacket(obj, 24243, 0, 0, 0, 0, obj.getDirection());\n\n//以map的坐标创建特效  参数分别是：对象，特效编号，等级，x坐标，y坐标，z坐标\nsq_SendCreatePassiveObjectPacketPos(parentObj, 24256, 0, x, y, z);\n\n//以父对象的坐标创建特效 参数分别是：对象，特效编号，等级，x偏移，y偏移，z偏移\nsq_SendCreatePassiveObjectPacketFromPassivePos( obj, 24370, 0, 0, 0);\n\n//还有一个没测试 是缔造者的\nsq_CreatePassiveObjectAfterWarning(obj, 23505, skill_level, null);\n\n\n//传递\nsq_BinaryStartWrite();\nsq_BinaryWriteBool();\nsq_BinaryWriteFloat();\nsq_BinaryWriteWord();\nsq_BinaryWriteByte();\nsq_BinaryWriteDword();\n//人物传递\nobj.sq_StartWrite();\nobj.sq_WriteBool();\nobj.sq_WriteFloat();\nobj.sq_WriteWord();\nobj.sq_WriteByte();\nobj.sq_WriteDword();\n//接收\nreceiveData.getSize();\nreciveData.readBool();\nreciveData.readByte();\nreciveData.readWord();\nreciveData.readDword();\nreciveData.readFloat();\n\n\n//得到角色类型  得到角色转职类型\nENUM_CHARACTERJOB_SWORDMAN    &lt;-    0               ///    鬼剑\nENUM_CHARACTERJOB_FIGHTER    &lt;-    1                   ///    女格斗\nENUM_CHARACTERJOB_GUNNER    &lt;-    2                   ///    男枪\nENUM_CHARACTERJOB_MAGE    &lt;-    3                   ///    女魔法\nENUM_CHARACTERJOB_PRIEST    &lt;-    4                   ///    圣职者\nENUM_CHARACTERJOB_AT_GUNNER    &lt;-    5               ///    女枪\nENUM_CHARACTERJOB_THIEF    &lt;-    6                  ///    暗夜使者\nENUM_CHARACTERJOB_AT_FIGHTER    &lt;-    7              ///    男格斗\nENUM_CHARACTERJOB_AT_MAGE    &lt;-    8                  ///    男魔法\nENUM_CHARACTERJOB_DEMONIC_SWORDMAN    &lt;-    9    ///    黑暗武士\nENUM_CHARACTERJOB_CREATOR_MAGE    &lt;-    10        ///    缔造者\nENUM_CHARACTERJOB_MAX    &lt;-    11                ///    \n\nsq_getJob(obj);//得到角色类型\nsq_getGrowType(obj);//得到转职类型\n//得到我的角色\nlocal chr = sq_getMyCharacter();//得到我的角色\nlocal chr = sq_GetMyMasterCharacter();//得到我的主人角色\n//施放技能时 创建读条 以及 删除读条\nlocal skill_level = sq_GetSkillLevel(obj, SKILL_ICEROAD);//技能等级\nlocal castTime = sq_GetCastTime(obj, SKILL_FIRE_ROAD, skill_level);//得到技能里面的施放时间\nsq_SetFrameDelayTime(animation, 0, castTime);//设置ani帧时间\n\n\nsq_StartDrawCastGauge(obj, castTime, true);//开始读条\nsq_EndDrawCastGauge(obj);//结束读条\n\n//霸体 隐身 无敌\n\n                POD_VAR_ARROW_COUNT        &lt;- 1; // 已使用的箭数\n                POD_VAR_CIRCLE_INDEX        &lt;- 2; // 生成的具体索引\n                POD_VAR_CIRCLE_OBJECT_GROUP    &lt;- 3; // 创建的具体组\n                POD_VAR_CIRCLE_OBJECT_UID        &lt;- 4; // 创建的具体UID\n                POD_VAR_CIRCLE_OBJECT        &lt;- 5; // 已创建的球体\n                POD_VAR_SUPERARMOR        &lt;- 6; // 超级智能侦探\n                POD_VAR_FLASHSCREEN        &lt;- 7; // 已创建的球体\n                //此霸体必须在状态结束时 删除霸体，不然会一直存在  如果是复仇者的话sq_后面一个字母改为小写即可\nobj.sq_SetSuperArmor(POD_VAR_SUPERARMOR);\nobj.sq_RemoveSuperArmor(POD_VAR_SUPERARMOR);\nobj.sq_SetSuperArmorUntilTime(obj, 1000);//霸体多长时间自动销毁\n\n\n//参数3\n//2无敌\nDAMAGETYPE_SUPERARMOR = 1\nDAMAGETYPE_NORMAL = 0\nsq_SetCustomDamageType(obj, true, 1); //设置损伤类型\n\n//设置旋转角度\nobj.setCustomRotate(true, angle);//对象类\nsq_SetCustomRotate(obj, 0.0);//任意对象 旋转\nsq_SetfRotateAngle(pAni, angle);//给ani设置旋转\nsq_AddfRotateAngle(pAni, angle);//给ani设置旋转\n\n变量.tofloat();//转为浮点数\n变量.tointeger();//转为整数型\n\n//atan2 参数1：长度 参数2：高度//那么就会得到 靠近高度的三角形角度\n//atan2 得到的就是弧度\n\n//sq_ToDegree 得到的是角度\n//sq_ToRadian 转为弧度\n//转为弧度后 再给予函数进行旋转\n//也可以直接给 sq_ToRadian(90.0);//那么就是得到90°的旋转弧度\n\nlocal angle = sq_ToDegree(sq_Atan2(x.tofloat(), z.tofloat()));//转为角度\nsq_ToRadian(angle);//将角度转化为弧度\n\n//发送冷却未完毕的公告消息\nobj.startCantUseSkillWarning();\nif (obj.isMessage()) sq_AddMessage(414);//冷却未完毕\n\n//设置 或 判断 冷却时间 或者与技能相关\n//批量设置冷却\nlocal bursterSkill = sq_GetSkill(chr, SKILL_BURSTER);//得到技能\nlocal pIntVec = sq_GetGlobalIntVector();//包\nsq_IntVectorClear(pIntVec);//清除\nsq_IntVectorPush(pIntVec, SKILL_BURSTER);//加入技能ID\nlocal size = sq_GetCustomIntDataSize(bursterSkill, chr);//得到技能的静态数据范围\nfor (local i = 0; i &lt; size; i++)\n{\n        local disableSkillIndex = sq_GetIntData(chr, SKILL_BURSTER, i);//得到静态数据\n        sq_IntVectorPush(pIntVec, disableSkillIndex);//加入技能ID\n}\n//参数1：角色\n//参数2：冷却时间\n//参数3：包\nsq_SetStartCoolTime(chr, 0, pIntVec);//设置冷却\nsq_SendMessage(parentObj, OBJECT_MESSAGE_GHOST, 1, 0);\nsq_PostDelayedMessage(parentObj, OBJECT_MESSAGE_GHOST, 0, 0, 8000);\n\n//判断技能是否处于冷却状态下\nsq_GetSkill(obj, 69).isInCoolTime();//是否处于冷却\n//重置冷却\nlocal skill = sq_GetSkill(obj, SKILL_ICEROAD);//得到技能\nskill.resetCurrentCoolTime();//重置冷却\n使技能进入冷却\nlocal skill_level = sq_GetSkillLevel(obj, SKILL_ICEROAD);//得到技能等级\nobj.startSkillCoolTime(SKILL_ICEROAD, skill_level, -1);//开始技能冷却\n\n//判断技能是否开启  或者 设置技能是否可使用 #就是可以更改开关的技能\nlocal skill = sq_GetSkill(obj, SKILL_ICEROAD);\nskill.isSealActiveFunction();//判断是否开启\nskill.setSealActiveFunction(true);//true开启 false关闭\n\n//判断对象类型 判断是否是相同对象 是否是敌人  是否死亡\nobject.isObjectType(OBJECTTYPE_ACTIVE);//控制对象类 判断对象类型\nobj.isEnemy(object);//控制类对象 是否是敌人\n\nlocal activeObj = sq_GetCNRDObjectToActiveObject(object);\nactiveObj.isDead();//活动类对象 是否死亡\n\nisSameObject(obj, object);//判断是否是相同对象\n\n\n\n\n                OBJECTTYPE_OBJECT &lt;- 0           //  譆鼻嬪 螃粽薛\n                OBJECTTYPE_COLLISION &lt;- 1           //  醱給 螃粽薛 (OBJECTTYPE_OBJECT 嬪)\n                OBJECTTYPE_ACTIVE &lt;- 17           //  棟翕 螃粽薛 (OBJECTTYPE_COLLISION 嬪)\n                OBJECTTYPE_CHARACTER &lt;- 273           //  議葛攪 螃粽薛 (OBJECTTYPE_ACTIVE 嬪)\n                OBJECTTYPE_MONSTER &lt;- 529           //  跨蝶攪 螃粽薛 (OBJECTTYPE_ACTIVE 嬪)\n                OBJECTTYPE_RIDABLEOBJECT &lt;- 4625           //  驍匙 婦溼 螃粽薛 (OBJECTTYPE_MONSTER 嬪)\n                OBJECTTYPE_PASSIVE &lt;- 33           //  熱翕 螃粽薛 (OBJECTTYPE_COLLISION 嬪)\n                OBJECTTYPE_ITEM &lt;- 289           //  嬴檜蠱 螃粽薛 (OBJECTTYPE_PASSIVE 嬪)\n                OBJECTTYPE_TRAP &lt;- 545           //  椰 螃粽薛 (OBJECTTYPE_PASSIVE 嬪)\n                OBJECTTYPE_BREAKABLE &lt;- 1057           //  惚 陛棟 螃粽薛(爾僭鼻濠 售) (OBJECTTYPE_PASSIVE 嬪)\n                OBJECTTYPE_PET &lt;- 65           //  褐熱 (OBJCTTYPE_COLLISION 嬪)\n                OBJECTTYPE_CREATURE &lt;- 129           //  觼葬藥 (OBJCTTYPE_COLLISION 嬪)\n                OBJECTTYPE_DRAWONLY &lt;- 2           //  斜葬晦 瞪辨 螃粽薛 (OBJECTTYPE_OBJECT 嬪)\n                OBJECTTYPE_VIRTUALCHARACTER &lt;- 18           //  渠晦褒縑憮 噙朝 陛鼻 議葛攪 (OBJECTTYPE_DRAWONLY 嬪)\n                OBJECTTYPE_NPC &lt;- 34           //  渠晦褒曖 NPC (OBJECTTYPE_DRAWONLY 嬪)\n                OBJECTTYPE_DONKEY &lt;- 66           //  渠晦褒曖 偃檣鼻薄 (OBJECTTYPE_DRAWONLY 嬪)\n                OBJECTTYPE_VIRTUALCREATURE &lt;- 130           //  渠晦褒縑憮 噙朝 陛鼻 觼葬藥(OBJECTTYPE_DRAWONLY 嬪)\n                OBJECTTYPE_DISJOINTSHOP &lt;- 258           //  渠晦褒曖 羹陛 羹 鼻薄(OBJECTTYPE_DRAWONLY 嬪)\n                OBJECTTYPE_VIRTUALMONSTER &lt;- 514           //  渠晦褒縑憮 噙朝 陛鼻 跨蝶攪 (OBJECTTYPE_DRAWONLEY 嬪)\n                OBJECTTYPE_NONE_DELETE &lt;- 1026           //  螃粽薛 餉薯 衛 餉薯腎雖 彊朝 螃粽薛 (OBJECTTYPE_DRAWONLEY 嬪) \n                OBJECTTYPE_DEFINE_END &lt;- 61440\n\n//hp mp相关 #设置hp或者mp或者得到\n//根据转换率得到转换后的实际hp值\n数值需要通过运算后得到正确数值\nlocal convert_rate = sq_GetAbilityConvertRate(obj, CONVERT_TABLE_TYPE_HP);//先得到转换率\nlocal dooms_con_hp = dooms_hp.tofloat() * convert_rate.tofloat();//得到正确的数值\n\n//转换常量\nCONVERT_TABLE_TYPE_DAMAGE &lt;- 0   //  等嘐雖\nCONVERT_TABLE_TYPE_DEFENSE &lt;- 1   //  寞橫溘\nCONVERT_TABLE_TYPE_HP &lt;- 2   //  HP MAX\nCONVERT_TABLE_TYPE_PHYSICAL_ATTACK &lt;- 3   //  \nCONVERT_TABLE_TYPE_PHYSICAL_DEFENSE &lt;- 4   //  羹溘\nCONVERT_TABLE_TYPE_MAGICAL_ATTACK &lt;- 5   //  雖棟\nCONVERT_TABLE_TYPE_MAGICAL_DEFENSE &lt;- 6   //  薑褐溘\nCONVERT_TABLE_TYPE_PHYSICAL_ABSOLUTE_DAMAGE &lt;- 7   //  僭葬 瞰渠 等嘐雖\nCONVERT_TABLE_TYPE_PHYSICAL_DAMAGE_REDUCE &lt;- 8   //  僭葬 等嘐雖 爾薑\nCONVERT_TABLE_TYPE_MAGICAL_ABSOLUTE_DAMAGE &lt;- 9   //  葆徹 瞰渠 等嘐雖\nCONVERT_TABLE_TYPE_MAGICAL_DAMAGE_REDUCE &lt;- 10   //  葆徹 等嘐雖 爾薑\nCONVERT_TABLE_TYPE_ACTIVESTATUS_DAMAGE_REDUCE &lt;- 11   //  鼻鷓檜鼻 等嘐雖 爾薑.\nCONVERT_TABLE_TYPE_MP &lt;- 12   //  MP MAX\nCONVERT_TABLE_TYPE_SKILL_POWER &lt;- 13   //  蝶鑒 絮董等嘐雖\nCONVERT_TABLE_TYPE_MAX &lt;- 14\n//得到  设置 hp mp\nobj.getHpMax();//活动类 得到hp上限\nobj.getHp();//活动类 得到当前hp\nobj.setHp(0, null, true);//活动类 设置hp\n\nobj.getMpMax();//活动类 得到mp上限\nobj.getMp();// 活动类 得到当前mp\nobj.sendSetMpPacket(obj.getMpMax());//活动类 设置mp\n\n\nsqrObj.sq_SendSetHpPacket(sqrObj.getHp() + hp, true, parentObj);//角色类 设置hp\nsqrObj.sq_SendSetMpPacket(sqrObj.getHp() + hp, true, parentObj);//角色类 设置mp\n\n//移动视角\n//自带比较简单的移动；会受到人物的方向所影响\nobj.sq_SetXScrollStart(500, 0);//开始移动视角；1.移动距离 2.达到距离时间\nobj.sq_SetXScrollStop(500);//回归视角 1.视角回归总时间\nobj.sq_SetXScroll(1000, 500, 0, 500);//移动视角 1.移动距离 2.达到时间 3.等待时间 4.回归时间\n\n//发送破坏对象包\nif(!parentObj)\n        {\n           if(obj.isMyControlObject())\n                {\n                        //发送摧毁包被动对象；销毁obj特效\n                        sq_SendDestroyPacketPassiveObject(obj);\n                        return;\n                }\n        }\n\nobj.sendDestroyPacket(true);//对象类 发送破坏包\n\n\n//得到随机数\n\n//这个随机 只要第一个参数不为true 则取得随机数不会重复，但是会返回-1，参数2 最小值随机数不能小于0\n//参数3 随机数，如果设置20，那么只会随机到19，不会随机到20\nlocal index = sq_getRandomUnique(true, 0, ::ElementalRainCreatePos.len());\n\nsq_getRandom(10,20);//数值随机 可以小于0\nsq_getRandomFloat(0.1,0.9);//浮点数随机，没试过\n\n\n\n//得到控制对象的lst列表的ID\nobj.getCollisionObjectIndex();//控制类对象 得到lstId\n\n//得到人物当前的技能ID\nlocal skillIndex = obj.getCurrentSkillIndex();//活动类对象 得到技能ID\n\n\n//得到当前副本 或 map的ID\n\nocal stage = sq_GetGlobaludpModuleStage();//得到模块\nlocal dungeon = sq_GetDungeonByStage(stage);//得到副本模块\nlocal dungeonIndex = sq_GetDuegonIndex(dungeon);//得到副本ID\nlocal mapIndex = sq_GetMapIndex(stage);//得到mapID\n\n\n//得到当前场景模块类型\n//得到当前的场景模块类型\nsq_GetCurrentModuleType();\n//1是城镇 3是副本中\n\nMODULE_TYPE_NONE &lt;- -1\nMODULE_TYPE_ENTRANCE &lt;- 0\nMODULE_TYPE_ROOM_LIST &lt;- 1    // 마을                                      \nMODULE_TYPE_SELECT_DUNGEON &lt;- 2                // 던전 선택화면\nMODULE_TYPE_MAIN_GAME &lt;- 3                    // 일반던전(이계 포함)\nMODULE_TYPE_PVP &lt;- 4                        // 결장\nMODULE_TYPE_FAIR_PVP &lt;- 5                    // 공결\n//MODULE_TYPE_LABYRINTH &lt;- 7                // 사라짐\nMODULE_TYPE_SELECT_CHANNEL &lt;- 6                                                                                      \nMODULE_TYPE_WARROOM &lt;- 7                    // 전쟁지역\n//MODULE_TYPE_CHAOS &lt;- 8                    \nMODULE_TYPE_LOGIN &lt;- 8\nMODULE_TYPE_ASSAULT &lt;- 9                    // 싸우자\nMODULE_TYPE_DEAD_TOWER &lt;- 10                    // 사탑\nMODULE_TYPE_BLOOD_SYSTEM &lt;- 11                // 무한의 제단\nMODULE_TYPE_DESPAIR_TOWER &lt;- 12            //절망의탑\n// 글로벌실 컨텐츠\nMODULE_TYPE_BOSS_TOWER &lt;- 13            //심연의 투기장\nMODULE_TYPE_ADVANCE_ALTAR &lt;- 14            //진격의 제단\nMODULE_TYPE_LOAD &lt;- 15\nMODULE_TYPE_TOURNAMENT &lt;- 16\nMODULE_TYPE_MAX &lt;- 17\nMODULE_TYPE_PVP_TYPE &lt;- 18            // 결투장, 싸우자, 전쟁지역을 합쳐 지칭\nMODULE_TYPE_DUNGEON_TYPE &lt;- 19        // 던전, 사탑, 무제를 합쳐 지칭\nMODULE_TYPE_ALL &lt;- 20            \n//MODULE_TYPE_LOAD &lt;- 13\n//MODULE_TYPE_TOURNAMENT &lt;- 14\n//MODULE_TYPE_MAX &lt;- 15\n//MODULE_TYPE_PVP_TYPE &lt;- 16            // 결투장, 싸우자, 전쟁지역을 합쳐 지칭\n//MODULE_TYPE_DUNGEON_TYPE &lt;- 17        // 던전, 사탑, 무제를 합쳐 지칭\n//MODULE_TYPE_ALL &lt;- 18                // 모든 모듈을 지칭\n\n\n//判断是否是我提供的技能等级以上\nobj.isOverSkillLevel(SKILL_AVENGER_AWAKENING, 4);//角色类\n\n\n//判断对象是否处于map某个范围内\n\nsq_IsinMapArea(obj, object, firstTargetXStartRange, firstTargetXEndRange, firstTargetYRange);\n\n//是否是存在对象\n\nsq_IsExistObject(parentObj, source);                                \n\n\n//是否在pvp模块\n\nsq_isPVPMode();\n\n\n//判断副本类型 #是否是塔  #是否是古老副本\nlocal stage = sq_GetGlobaludpModuleStage();//得到模块\nlocal dungeon = sq_GetDungeonByStage(stage);//得到副本\n\nlocal isDimensionDungeon = sq_IsDimensionDungeon(dungeon);//维度地牢\nlocal isDespairTower = sq_IsDespairTower(dungeon);//绝望塔\nlocal isAncientDungeon = sq_IsAncientDungeon(dungeon);//古老地牢\nlocal isTower = sq_IsTowerDungeon();//塔\n\n//设置边框轮廓 #描边效果\n\nsq_SetObjectBounding(obj, jumpVelocity);\n//最后一个参数是 描边像素宽度\nobj.setCustomOutline(false, 0, true, 2);\nobj.setCustomOutline(true, rgb, false, 1);\nobj.setCustomOutline(true, sq_RGBA(255, 0, 0, 10), false, 4);\n\n\n//在画ui函数中用到的函数方法 #函数drawCustomUI\n\n//普通画动图ui\n\nsq_AnimationProc(ani);\nsq_drawCurrentFrame(ani, x, y, false);\n\n//可以增加rgb 或者透明度\nsq_AnimationProc(gauge_normal_flash);\nsq_drawCurrentFrameEffect_SIMPLE(gauge_normal_flash, x, y, rgb, alpha);\n\n\n//画的固定帧 坐标是取的绝对屏幕坐标\nsq_DrawSpecificFrame(hudCreatorAni, x, y, false, 0, false, 1.0);\n\n//rgba\nsq_DrawSpecificFrameEffect_SIMPLE(hud_creator_b_gauge, gaugePosX + (slot * offset), y, 0, rgb, alpha, true);\n\n//没用过这个 原版是在特效中的被动 但是被注释掉了\nsq_drawCurrentFrameEffectColor(ani, GRAPHICEFFECT_MONOCHROME, true, sq_RGB(255,255,255), sq_ALPHA(255));\n\n//画出预设弹窗文字\nsq_drawToolTip(x - 35, y - 13, sq_RGB(255,255,255), 0, 1, 29003, 0, 260, true);\n\n\n//数值类型转换\n//转为浮点数\n//变量.tofloat()\n//转为整数型\n//变量.tointeger()\n//转为整数型\n//变量.tostring()\n//字符串取长度\nlocal len = Value.len();\n//分割\nlocal son = Value.slice(i,i+1);\n\n\n设置跟随过图\n//设置跟随对象 控制类\nobj.setMapFollowParent(obj.getParent());//设置跟随对象\n//设置跟随的类型\nobj.setMapFollowType(1);//设置跟随类型\n//1//跟着过图 会出现在门周围\n//2;//跟着过图 会出现在门周围\n//3;//跟着过图 坐标会有点乱。。\n//4;//跟着过图 坐标在门的前方\n//5，6;//跟着过图 过图后坐标为0 0 0\n\n//得到团队类型\nparentObj.sq_GetTeam();//角色类 得到团队类型\nattacker.getTeam();//控制类对象 得到团队类型\n\n//得到当前武器sub使用类型\nobj.getWeaponSubType();\n\n\n//得到怪物种类 #例如精灵什么的\nsq_IsInCategory(parentObj,CATEGORY_ETC_FIXTURE);\n\n//检测怪物类型 #例如深渊或者boss之类等等\nlocal activeObj = sq_GetCNRDObjectToActiveObject(object);//转为活动类对象\n\nsq_IsAiCharacter(activeObj);//是否是apc人偶\nsq_IsNamed(activeObj);//是否是精英怪物\nsq_IsHellMonster(activeObj);//是否是深渊怪物\nsq_IsBoss(activeObj);//是否是BOSS怪物\n\nactiveObj.isChampion();//是否是异常状态怪物 活动类\nactiveObj.isCommonChampion();//是否是常见异常怪物 活动类\nactiveObj.isSuperChampion();//是否是超级异常怪物 活动类\n\nobj.isEnemy(object);//是否是敌人 控制类\n\n//通过攻击框得出中心点坐标\nlocal x = sq_GetCenterXPos(boundingBox);//得到边界框的x轴中心点\nlocal y = sq_GetCenterYPos(boundingBox);//得到边界框的y轴中心点\nlocal z = sq_GetCenterZPos(boundingBox);//得到边界框的z轴中心点\n\n\n//强制掉线 #运行后游戏直接奔溃\nsetBreak(obj); \nsetBreak();\n\n//暂停 #暂停 #让其停止\nsq_SetPause(obj, PAUSETYPE_OBJECT, pauseTime);\n\nPAUSETYPE_NONE        &lt;- 0    /// 일시정지 안함\nPAUSETYPE_OBJECT    &lt;- 1    /// 只有对象是暂时中止(Appendage，状态变化，效果是继续旋转，重力未应用)\nPAUSETYPE_WORLD        &lt;- 2    /// 全世界都暂停了。\n\nlocal currentAni = obj.getCurrentAnimation();//当前ani\ncurrentAni.SetPause(true);//true暂停播放 false正常播放\n\n\n//特效设置最大攻击上限 #攻击一定命中一定不会再攻击\nobj.sq_SetMaxHitCounterPerObject(maxHit);//设置最大攻击次数\n\n//提供物品ID 检查该物品是否是恢复类道具\n\nlocal isRecover = sq_IsItemRecover(itemIndex);\n\n//得到buff图标数量\n\nsq_getMyBuffInfoCount();\n\n//得到Throw属性 设置Throw属性 #没测试\n//得到元素类型\nlocal type = parentObj.getThrowElement();\nobj.setThrowElement(element);\nENUM_ELEMENT_FIRE &lt;- 0 /// 火属性\nENUM_ELEMENT_WATER &lt;- 1 /// 冰属性\nENUM_ELEMENT_DARK &lt;- 2 /// 暗属性\nENUM_ELEMENT_LIGHT &lt;- 3 /// 光属性\nENUM_ELEMENT_NONE &lt;- 4 /// 无属性\nENUM_ELEMENT_MAX &lt;- 4 /// == ENUM_ELEMENT_NONE\n\n//是否处于战场\n//得到父对象\nlocal parentObject = appendage.getParent();\n//得到角色对象\nlocal parentObj = sq_ObjectToSQRCharacter(parentObject);\n//检查是否处于战斗\nparentObj.isInBattle();//角色类\nsq_IsInBattle()\n\n//判断是否处于技能不可使用的map房间中\nobj.isInActiveSkillBlockedMap();//角色类\n\n//判断是否处于暂停类型世界中\nsq_IsPauseTypeWorld(obj)\n\n//设置普攻时的移动信息\nobj.setAttackXVelocity(250);\nobj.setAttackXAccel(-1000);\nobj.setAttackXVelocityFast(400);\nobj.setAttackXAccelFast(-1000);\n\n//得到攻击ID\n\nlocal attackIndex = obj.getAttackIndex();//活动类\n\n//杂乱\n//无测试1\npo特效\n//得到角色\nlocal chr = obj.getTopCharacter();\n//如果角色不为null\nif (chr)\n{\n         local map = sq_GetMap(chr);//得到map\n         if (map)\n         {\n                map.recalcAStarAttributesByMovableObject(obj, false);？\n         }\n}\n\n//无测试2\n//增加攻击对象，好像是设定 我攻击到它了\nlocal damager = sq_GetObject(parentObj, group, id);\nlocal colObj = sq_GetCNRDObjectToCollisionObject(damager);\nif(colObj &amp;&amp; parentObj) \n        sq_AddHitObject(obj, colObj);\n                local flashScreenObj = sq_var.getObject(POD_VAR_FLASHSCREEN);\n                if(flashScreenObj) { // 플래쉬 스크린 작동중이면 끔\n                        local pflashScreen = sq_GetCNRDObjectToFlashScreen(flashScreenObj);\n                        if(pflashScreen)\n                                pflashScreen.fadeOut();\n                }\n                local grabChr = sq_GetCNRDObjectToSQRCharacter(vObj);\n                if(grabChr)\n                {\n                        local cmdChecker = grabChr.getCommandChecker();\n                        grabChr.initCommandChecker(cmdChecker, true); // 자신이 콘트롤하기 위해 커맨드체커 ai플래그 부분을 true로 바꿉니다.\n                        grabChr.setCommandChecker(cmdChecker);\n                        // 커맨트 체크에서 ai모드가 on인지 off인지 체크하는 플래그를 세팅하는 함수 입니다.\n                        cmdChecker.setAIMode(true);  \n                        // 다음방으로 이용하기 위해 쓰인 플래그 입니다. 내가 ai가 콘트롤하는 오브젝트인지 체크하는 플래그 입니다 (irdsqrcharacter)\n                        grabChr.setAIModeByControlObject(true);  \n                        local onlyAiChr = sq_GetCNRDObjectToAICharacter(grabChr);\n                        sq_SetTargetObjectAICharacter(onlyAiChr, null, false);\n                        local skillMgr = grabChr.getSkillManager();\n                        if(skillMgr)\n                        {\n                                skillMgr.setParent(grabChr);\n                                        skillMgr.setCommandChecker(cmdChecker);    // 스킬매니저와 커맨드체커를 연결\n                                local skillTree = grabChr.getCurrentSkillTree();\n                                skillMgr.addAllKeyCommand(skillTree);\n                                grabChr.flushCommandEnable();\n                        }\n                }\n\n\n\n//被动增加伤害\nsqrObj.sq_RemovePassiveSkillAttackBonusRate(SKILL_MANABURST);\nsqrObj.sq_AddPassiveSkillAttackBonusRate(SKILL_MANABURST, SKL_LVL_COLUMN_IDX_1);\n\n//技能密封\nlocal skill = sq_GetSkill(parentChr, SKILL_TUNDRASOUL);\nif(skill.isSealFunction())\n//开关 在skl里面写个这个就行了\n[seal enable]\n        1    \n\n</code></pre>\n\n<p>&nbsp;</p>",
    "auth_users": "旭旭姥姥",
    "img": "",
    "create_at": "2023-06-18T14:21:43.324",
    "view_num": 4840
}